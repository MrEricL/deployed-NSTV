{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { changeBitDepth } from './codecs/bitdepth';\nimport * as imaadpcm from './codecs/imaadpcm';\nimport * as alaw from './codecs/alaw';\nimport * as mulaw from './codecs/mulaw';\nimport { unpackArrayTo } from './parsers/binary';\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\nimport { validateSampleRate } from './validators/validate-sample-rate';\nimport { resample } from './resampler';\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\n\nexport var WaveFileConverter = /*#__PURE__*/function (_WaveFileCueEditor) {\n  _inherits(WaveFileConverter, _WaveFileCueEditor);\n\n  var _super = _createSuper(WaveFileConverter);\n\n  function WaveFileConverter() {\n    _classCallCheck(this, WaveFileConverter);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(WaveFileConverter, [{\n    key: \"toRIFF\",\n    value:\n    /**\r\n     * Force a file as RIFF.\r\n     */\n    function toRIFF() {\n      /** @type {!Float64Array} */\n      var output = new Float64Array(outputSize_(this.data.samples.length, this.dataType.bits / 8));\n      unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, this.bitDepth, output, {\n        container: 'RIFF'\n      });\n    }\n    /**\r\n     * Force a file as RIFX.\r\n     */\n\n  }, {\n    key: \"toRIFX\",\n    value: function toRIFX() {\n      /** @type {!Float64Array} */\n      var output = new Float64Array(outputSize_(this.data.samples.length, this.dataType.bits / 8));\n      unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, this.bitDepth, output, {\n        container: 'RIFX'\n      });\n    }\n    /**\r\n     * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n     * @throws {Error} If sample rate is not 8000.\r\n     * @throws {Error} If number of channels is not 1.\r\n     */\n\n  }, {\n    key: \"toIMAADPCM\",\n    value: function toIMAADPCM() {\n      if (this.fmt.sampleRate !== 8000) {\n        throw new Error('Only 8000 Hz files can be compressed as IMA-ADPCM.');\n      } else if (this.fmt.numChannels !== 1) {\n        throw new Error('Only mono files can be compressed as IMA-ADPCM.');\n      } else {\n        this.assure16Bit_();\n        /** @type {!Int16Array} */\n\n        var output = new Int16Array(outputSize_(this.data.samples.length, 2));\n        unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n        this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '4', imaadpcm.encode(output), {\n          container: this.correctContainer_()\n        });\n      }\n    }\n    /**\r\n     * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n     * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n     *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n     */\n\n  }, {\n    key: \"fromIMAADPCM\",\n    value: function fromIMAADPCM() {\n      var bitDepthCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '16';\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', imaadpcm.decode(this.data.samples, this.fmt.blockAlign), {\n        container: this.correctContainer_()\n      });\n\n      if (bitDepthCode != '16') {\n        this.toBitDepth(bitDepthCode);\n      }\n    }\n    /**\r\n     * Encode a 16-bit wave file as 8-bit A-Law.\r\n     */\n\n  }, {\n    key: \"toALaw\",\n    value: function toALaw() {\n      this.assure16Bit_();\n      /** @type {!Int16Array} */\n\n      var output = new Int16Array(outputSize_(this.data.samples.length, 2));\n      unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '8a', alaw.encode(output), {\n        container: this.correctContainer_()\n      });\n    }\n    /**\r\n     * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n     * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n     *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n     */\n\n  }, {\n    key: \"fromALaw\",\n    value: function fromALaw() {\n      var bitDepthCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '16';\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', alaw.decode(this.data.samples), {\n        container: this.correctContainer_()\n      });\n\n      if (bitDepthCode != '16') {\n        this.toBitDepth(bitDepthCode);\n      }\n    }\n    /**\r\n     * Encode 16-bit wave file as 8-bit mu-Law.\r\n     */\n\n  }, {\n    key: \"toMuLaw\",\n    value: function toMuLaw() {\n      this.assure16Bit_();\n      /** @type {!Int16Array} */\n\n      var output = new Int16Array(outputSize_(this.data.samples.length, 2));\n      unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '8m', mulaw.encode(output), {\n        container: this.correctContainer_()\n      });\n    }\n    /**\r\n     * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n     * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n     *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n     */\n\n  }, {\n    key: \"fromMuLaw\",\n    value: function fromMuLaw() {\n      var bitDepthCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '16';\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', mulaw.decode(this.data.samples), {\n        container: this.correctContainer_()\n      });\n\n      if (bitDepthCode != '16') {\n        this.toBitDepth(bitDepthCode);\n      }\n    }\n    /**\r\n     * Change the bit depth of the samples.\r\n     * @param {string} newBitDepth The new bit depth of the samples.\r\n     *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n     * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n     *    resolution of samples should be actually changed or not.\r\n     * @throws {Error} If the bit depth is not valid.\r\n     */\n\n  }, {\n    key: \"toBitDepth\",\n    value: function toBitDepth(newBitDepth) {\n      var changeResolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      /** @type {string} */\n      var toBitDepth = newBitDepth;\n      /** @type {string} */\n\n      var thisBitDepth = this.bitDepth;\n\n      if (!changeResolution) {\n        if (newBitDepth != '32f') {\n          toBitDepth = this.dataType.bits.toString();\n        }\n\n        thisBitDepth = '' + this.dataType.bits;\n      } // If the file is compressed, make it\n      // PCM before changing the bit depth\n\n\n      this.assureUncompressed_();\n      /**\r\n       * The original samples, interleaved.\r\n       * @type {!(Array|TypedArray)}\r\n       */\n\n      var samples = this.getSamples(true);\n      /**\r\n       * The container for the new samples.\r\n       * @type {!Float64Array}\r\n       */\n\n      var newSamples = new Float64Array(samples.length); // Change the bit depth\n\n      changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth); // Re-create the file\n\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, newBitDepth, newSamples, {\n        container: this.correctContainer_()\n      });\n    }\n    /**\r\n     * Convert the sample rate of the file.\r\n     * @param {number} sampleRate The target sample rate.\r\n     * @param {Object=} options The extra configuration, if needed.\r\n     */\n\n  }, {\n    key: \"toSampleRate\",\n    value: function toSampleRate(sampleRate, options) {\n      this.validateResample_(sampleRate);\n      /** @type {!(Array|TypedArray)} */\n\n      var samples = this.getSamples();\n      /** @type {!(Array|Float64Array)} */\n\n      var newSamples = []; // Mono files\n\n      if (samples.constructor === Float64Array) {\n        newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options); // Multi-channel files\n      } else {\n        for (var i = 0; i < samples.length; i++) {\n          newSamples.push(resample(samples[i], this.fmt.sampleRate, sampleRate, options));\n        }\n      } // Recreate the file\n\n\n      this.fromExisting_(this.fmt.numChannels, sampleRate, this.bitDepth, newSamples, {\n        'container': this.correctContainer_()\n      });\n    }\n    /**\r\n     * Validate the conditions for resampling.\r\n     * @param {number} sampleRate The target sample rate.\r\n     * @throws {Error} If the file cant be resampled.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"validateResample_\",\n    value: function validateResample_(sampleRate) {\n      if (!validateSampleRate(this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\n        throw new Error('Invalid sample rate.');\n      } else if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1) {\n        throw new Error('wavefile can\\'t change the sample rate of compressed files.');\n      }\n    }\n    /**\r\n     * Make the file 16-bit if it is not.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"assure16Bit_\",\n    value: function assure16Bit_() {\n      this.assureUncompressed_();\n\n      if (this.bitDepth != '16') {\n        this.toBitDepth('16');\n      }\n    }\n    /**\r\n     * Uncompress the samples in case of a compressed file.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"assureUncompressed_\",\n    value: function assureUncompressed_() {\n      if (this.bitDepth == '8a') {\n        this.fromALaw();\n      } else if (this.bitDepth == '8m') {\n        this.fromMuLaw();\n      } else if (this.bitDepth == '4') {\n        this.fromIMAADPCM();\n      }\n    }\n    /**\r\n     * Return 'RIFF' if the container is 'RF64', the current container name\r\n     * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n     * @return {string}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"correctContainer_\",\n    value: function correctContainer_() {\n      return this.container == 'RF64' ? 'RIFF' : this.container;\n    }\n    /**\r\n     * Set up the WaveFileCreator object based on the arguments passed.\r\n     * This method only reset the fmt , fact, ds64 and data chunks.\r\n     * @param {number} numChannels The number of channels\r\n     *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n     * @param {number} sampleRate The sample rate.\r\n     *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n     * @param {string} bitDepthCode The audio bit depth code.\r\n     *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n     *    or any value between '8' and '32' (like '12').\r\n     * @param {!(Array|TypedArray)} samples\r\n     *    The samples. Must be in the correct range according to the bit depth.\r\n     * @param {Object} options Used to define the container. Uses RIFF by default.\r\n     * @throws {Error} If any argument does not meet the criteria.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"fromExisting_\",\n    value: function fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\n      /** @type {!Object} */\n      var tmpWav = new WaveFileCueEditor();\n      Object.assign(this.fmt, tmpWav.fmt);\n      Object.assign(this.fact, tmpWav.fact);\n      Object.assign(this.ds64, tmpWav.ds64);\n      Object.assign(this.data, tmpWav.data);\n      this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\n    }\n  }]);\n\n  return WaveFileConverter;\n}(WaveFileCueEditor);\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\n\nfunction outputSize_(byteLen, byteOffset) {\n  /** @type {number} */\n  var outputSize = byteLen / byteOffset;\n\n  if (outputSize % 2) {\n    outputSize++;\n  }\n\n  return outputSize;\n}","map":{"version":3,"sources":["/Users/eric/test/NSVT-FINAL/my-app/node_modules/wavefile/lib/wavefile-converter.js"],"names":["changeBitDepth","imaadpcm","alaw","mulaw","unpackArrayTo","WaveFileCueEditor","validateSampleRate","resample","WaveFileConverter","output","Float64Array","outputSize_","data","samples","length","dataType","bits","fromExisting_","fmt","numChannels","sampleRate","bitDepth","container","Error","assure16Bit_","Int16Array","encode","correctContainer_","bitDepthCode","decode","blockAlign","toBitDepth","newBitDepth","changeResolution","thisBitDepth","toString","assureUncompressed_","getSamples","newSamples","options","validateResample_","constructor","i","push","bitsPerSample","indexOf","fromALaw","fromMuLaw","fromIMAADPCM","tmpWav","Object","assign","fact","ds64","newWavFile_","byteLen","byteOffset","outputSize"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { changeBitDepth } from './codecs/bitdepth';\r\nimport * as imaadpcm from './codecs/imaadpcm';\r\nimport * as alaw from './codecs/alaw';\r\nimport * as mulaw from './codecs/mulaw';\r\nimport { unpackArrayTo } from './parsers/binary';\r\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { resample } from './resampler';\r\n\r\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\r\nexport class WaveFileConverter extends WaveFileCueEditor {\r\n\r\n  /**\r\n   * Force a file as RIFF.\r\n   */\r\n  toRIFF() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFF'});\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFX.\r\n   */\r\n  toRIFX() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFX'});\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   */\r\n  toIMAADPCM() {\r\n    if (this.fmt.sampleRate !== 8000) {\r\n      throw new Error(\r\n        'Only 8000 Hz files can be compressed as IMA-ADPCM.');\r\n    } else if (this.fmt.numChannels !== 1) {\r\n      throw new Error(\r\n        'Only mono files can be compressed as IMA-ADPCM.');\r\n    } else {\r\n      this.assure16Bit_();\r\n      /** @type {!Int16Array} */\r\n      let output = new Int16Array(\r\n        outputSize_(this.data.samples.length, 2));\r\n      unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n      this.fromExisting_(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        '4',\r\n        imaadpcm.encode(output),\r\n        {container: this.correctContainer_()});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromIMAADPCM(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      imaadpcm.decode(this.data.samples, this.fmt.blockAlign),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 8-bit A-Law.\r\n   */\r\n  toALaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8a',\r\n      alaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromALaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   */\r\n  toMuLaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8m',\r\n      mulaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromMuLaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      mulaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} newBitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   */\r\n  toBitDepth(newBitDepth, changeResolution=true) {\r\n    /** @type {string} */\r\n    let toBitDepth = newBitDepth;\r\n    /** @type {string} */\r\n    let thisBitDepth = this.bitDepth;\r\n    if (!changeResolution) {\r\n      if (newBitDepth != '32f') {\r\n        toBitDepth = this.dataType.bits.toString();\r\n      }\r\n      thisBitDepth = '' + this.dataType.bits;\r\n    }\r\n    // If the file is compressed, make it\r\n    // PCM before changing the bit depth\r\n    this.assureUncompressed_();\r\n    /**\r\n     * The original samples, interleaved.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = this.getSamples(true);\r\n    /**\r\n     * The container for the new samples.\r\n     * @type {!Float64Array}\r\n     */\r\n    let newSamples = new Float64Array(samples.length);\r\n    // Change the bit depth\r\n    changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth);\r\n    // Re-create the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      newBitDepth,\r\n      newSamples,\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Convert the sample rate of the file.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @param {Object=} options The extra configuration, if needed.\r\n   */\r\n  toSampleRate(sampleRate, options) {\r\n    this.validateResample_(sampleRate);\r\n    /** @type {!(Array|TypedArray)} */\r\n    let samples = this.getSamples();\r\n    /** @type {!(Array|Float64Array)} */\r\n    let newSamples = [];\r\n    // Mono files\r\n    if (samples.constructor === Float64Array) {\r\n      newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options);\r\n    // Multi-channel files\r\n    } else {\r\n      for (let i = 0; i < samples.length; i++) {\r\n        newSamples.push(resample(\r\n          samples[i], this.fmt.sampleRate, sampleRate, options));\r\n      }\r\n    }\r\n    // Recreate the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels, sampleRate, this.bitDepth, newSamples,\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Validate the conditions for resampling.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @throws {Error} If the file cant be resampled.\r\n   * @private\r\n   */\r\n  validateResample_(sampleRate) {\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    } else if (['4','8a','8m'].indexOf(this.bitDepth) > -1) {\r\n      throw new Error(\r\n        'wavefile can\\'t change the sample rate of compressed files.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\r\n  assure16Bit_() {\r\n    this.assureUncompressed_();\r\n    if (this.bitDepth != '16') {\r\n      this.toBitDepth('16');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\r\n  assureUncompressed_() {\r\n    if (this.bitDepth == '8a') {\r\n      this.fromALaw();\r\n    } else if (this.bitDepth == '8m') {\r\n      this.fromMuLaw();\r\n    } else if (this.bitDepth == '4') {\r\n      this.fromIMAADPCM();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  correctContainer_() {\r\n    return this.container == 'RF64' ? 'RIFF' : this.container;\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * This method only reset the fmt , fact, ds64 and data chunks.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples\r\n   *    The samples. Must be in the correct range according to the bit depth.\r\n   * @param {Object} options Used to define the container. Uses RIFF by default.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileCueEditor();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction outputSize_(byteLen, byteOffset) {\r\n  /** @type {number} */\r\n  let outputSize = byteLen / byteOffset;\r\n  if (outputSize % 2) {\r\n    outputSize++;\r\n  }\r\n  return outputSize;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}