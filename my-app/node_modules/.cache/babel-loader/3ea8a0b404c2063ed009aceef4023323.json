{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { unpackString, unpack } from './parsers/binary';\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\n\nexport var RIFFFile = /*#__PURE__*/function () {\n  function RIFFFile() {\n    _classCallCheck(this, RIFFFile);\n\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\n    this.container = '';\n    /**\r\n     * @type {number}\r\n     */\n\n    this.chunkSize = 0;\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\n\n    this.format = '';\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\n\n    this.signature = null;\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n\n    this.head = 0;\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\n\n    this.uInt32 = {\n      bits: 32,\n      be: false\n    };\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\n\n    this.supported_containers = ['RIFF', 'RIFX'];\n  }\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\n\n\n  _createClass(RIFFFile, [{\n    key: \"setSignature\",\n    value: function setSignature(buffer) {\n      this.head = 0;\n      this.container = this.readString(buffer, 4);\n\n      if (this.supported_containers.indexOf(this.container) === -1) {\n        throw Error('Not a supported format.');\n      }\n\n      this.uInt32.be = this.container === 'RIFX';\n      this.chunkSize = this.readUInt32(buffer);\n      this.format = this.readString(buffer, 4); // The RIFF file signature\n\n      this.signature = {\n        chunkId: this.container,\n        chunkSize: this.chunkSize,\n        format: this.format,\n        subChunks: this.getSubChunksIndex_(buffer)\n      };\n    }\n    /**\r\n      * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n      * @param {string} chunkId The chunk fourCC_.\r\n      * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n      *    with the same chunkId.\r\n      * @return {Object}\r\n      * @protected\r\n      */\n\n  }, {\n    key: \"findChunk\",\n    value: function findChunk(chunkId) {\n      var multiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /** @type {!Array<Object>} */\n      var chunks = this.signature.subChunks;\n      /** @type {!Array<Object>} */\n\n      var chunk = [];\n\n      for (var i = 0; i < chunks.length; i++) {\n        if (chunks[i].chunkId == chunkId) {\n          if (multiple) {\n            chunk.push(chunks[i]);\n          } else {\n            return chunks[i];\n          }\n        }\n      }\n\n      if (chunkId == 'LIST') {\n        return chunk.length ? chunk : null;\n      }\n\n      return null;\n    }\n    /**\r\n     * Read bytes as a string from a RIFF chunk.\r\n     * @param {!Uint8Array} bytes The bytes.\r\n     * @param {number} maxSize the max size of the string.\r\n     * @return {string} The string.\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"readString\",\n    value: function readString(bytes, maxSize) {\n      /** @type {string} */\n      var str = '';\n      str = unpackString(bytes, this.head, this.head + maxSize);\n      this.head += maxSize;\n      return str;\n    }\n    /**\r\n     * Read a number from a chunk.\r\n     * @param {!Uint8Array} bytes The chunk bytes.\r\n     * @return {number} The number.\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"readUInt32\",\n    value: function readUInt32(bytes) {\n      /** @type {number} */\n      var value = unpack(bytes, this.uInt32, this.head);\n      this.head += 4;\n      return value;\n    }\n    /**\r\n     * Return the sub chunks of a RIFF file.\r\n     * @param {!Uint8Array} buffer the RIFF file bytes.\r\n     * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getSubChunksIndex_\",\n    value: function getSubChunksIndex_(buffer) {\n      /** @type {!Array<!Object>} */\n      var chunks = [];\n      /** @type {number} */\n\n      var i = this.head;\n\n      while (i <= buffer.length - 8) {\n        chunks.push(this.getSubChunkIndex_(buffer, i));\n        i += 8 + chunks[chunks.length - 1].chunkSize;\n        i = i % 2 ? i + 1 : i;\n      }\n\n      return chunks;\n    }\n    /**\r\n     * Return a sub chunk from a RIFF file.\r\n     * @param {!Uint8Array} buffer the RIFF file bytes.\r\n     * @param {number} index The start index of the chunk.\r\n     * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getSubChunkIndex_\",\n    value: function getSubChunkIndex_(buffer, index) {\n      /** @type {!Object} */\n      var chunk = {\n        chunkId: this.getChunkId_(buffer, index),\n        chunkSize: this.getChunkSize_(buffer, index)\n      };\n\n      if (chunk.chunkId == 'LIST') {\n        chunk.format = unpackString(buffer, index + 8, index + 12);\n        this.head += 4;\n        chunk.subChunks = this.getSubChunksIndex_(buffer);\n      } else {\n        /** @type {number} */\n        var realChunkSize = chunk.chunkSize % 2 ? chunk.chunkSize + 1 : chunk.chunkSize;\n        this.head = index + 8 + realChunkSize;\n        chunk.chunkData = {\n          start: index + 8,\n          end: this.head\n        };\n      }\n\n      return chunk;\n    }\n    /**\r\n     * Return the fourCC_ of a chunk.\r\n     * @param {!Uint8Array} buffer the RIFF file bytes.\r\n     * @param {number} index The start index of the chunk.\r\n     * @return {string} The id of the chunk.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getChunkId_\",\n    value: function getChunkId_(buffer, index) {\n      this.head += 4;\n      return unpackString(buffer, index, index + 4);\n    }\n    /**\r\n     * Return the size of a chunk.\r\n     * @param {!Uint8Array} buffer the RIFF file bytes.\r\n     * @param {number} index The start index of the chunk.\r\n     * @return {number} The size of the chunk without the id and size fields.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getChunkSize_\",\n    value: function getChunkSize_(buffer, index) {\n      this.head += 4;\n      return unpack(buffer, this.uInt32, index + 4);\n    }\n  }]);\n\n  return RIFFFile;\n}();","map":{"version":3,"sources":["/Users/eric/test/herokutestcs/my-app/node_modules/wavefile/lib/riff-file.js"],"names":["unpackString","unpack","RIFFFile","container","chunkSize","format","signature","head","uInt32","bits","be","supported_containers","buffer","readString","indexOf","Error","readUInt32","chunkId","subChunks","getSubChunksIndex_","multiple","chunks","chunk","i","length","push","bytes","maxSize","str","value","getSubChunkIndex_","index","getChunkId_","getChunkSize_","realChunkSize","chunkData","start","end"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\r\nexport class RIFFFile {\r\n\r\n  constructor() {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\r\n    this.signature = null;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.head = 0;\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt32 = {bits: 32, be: false};\r\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\r\n    this.supported_containers = ['RIFF', 'RIFX'];\r\n  }\r\n\r\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\r\n  setSignature(buffer) {\r\n    this.head = 0;\r\n    this.container = this.readString(buffer, 4);\r\n    if (this.supported_containers.indexOf(this.container) === -1) {\r\n      throw Error('Not a supported format.');\r\n    }\r\n    this.uInt32.be = this.container === 'RIFX';\r\n    this.chunkSize = this.readUInt32(buffer);\r\n    this.format = this.readString(buffer, 4);\r\n    // The RIFF file signature\r\n    this.signature = {\r\n      chunkId: this.container,\r\n      chunkSize: this.chunkSize,\r\n      format: this.format,\r\n      subChunks: this.getSubChunksIndex_(buffer)\r\n    };\r\n  }\r\n\r\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\r\n  findChunk(chunkId, multiple=false) {\r\n    /** @type {!Array<Object>} */\r\n    let chunks = this.signature.subChunks;\r\n    /** @type {!Array<Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i].chunkId == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\r\n  readString(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    str = unpackString(bytes, this.head, this.head + maxSize);\r\n    this.head += maxSize;\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\r\n  readUInt32(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt32, this.head);\r\n    this.head += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunksIndex_(buffer) {\r\n    /** @type {!Array<!Object>} */\r\n    let chunks = [];\r\n    /** @type {number} */\r\n    let i = this.head;\r\n    while(i <= buffer.length - 8) {\r\n      chunks.push(this.getSubChunkIndex_(buffer, i));\r\n      i += 8 + chunks[chunks.length - 1].chunkSize;\r\n      i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n  }\r\n\r\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunkIndex_(buffer, index) {\r\n    /** @type {!Object} */\r\n    let chunk = {\r\n      chunkId: this.getChunkId_(buffer, index),\r\n      chunkSize: this.getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk.chunkId == 'LIST') {\r\n      chunk.format = unpackString(buffer, index + 8, index + 12);\r\n      this.head += 4;\r\n      chunk.subChunks = this.getSubChunksIndex_(buffer);\r\n    } else {\r\n      /** @type {number} */\r\n      let realChunkSize = chunk.chunkSize % 2 ?\r\n        chunk.chunkSize + 1 : chunk.chunkSize;\r\n      this.head = index + 8 + realChunkSize;\r\n      chunk.chunkData = {\r\n        start: index + 8,\r\n        end: this.head\r\n      };\r\n    }\r\n    return chunk;\r\n  }\r\n\r\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\r\n  getChunkId_(buffer, index) {\r\n    this.head += 4;\r\n    return unpackString(buffer, index, index + 4);\r\n  }\r\n\r\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\r\n  getChunkSize_(buffer, index) {\r\n    this.head += 4;\r\n    return unpack(buffer, this.uInt32, index + 4);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}