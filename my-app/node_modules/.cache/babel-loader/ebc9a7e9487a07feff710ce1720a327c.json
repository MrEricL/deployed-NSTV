{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileReader } from './wavefile-reader';\nimport { writeString } from './parsers/write-string';\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\n\nexport var WaveFileParser = /*#__PURE__*/function (_WaveFileReader) {\n  _inherits(WaveFileParser, _WaveFileReader);\n\n  var _super = _createSuper(WaveFileParser);\n\n  function WaveFileParser() {\n    _classCallCheck(this, WaveFileParser);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(WaveFileParser, [{\n    key: \"toBuffer\",\n    value:\n    /**\r\n     * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n     * The return value of this method can be written straight to disk.\r\n     * @return {!Uint8Array} A wav file.\r\n     */\n    function toBuffer() {\n      this.uInt16.be = this.container === 'RIFX';\n      this.uInt32.be = this.uInt16.be;\n      /** @type {!Array<!Array<number>>} */\n\n      var fileBody = [this.getJunkBytes_(), this.getDs64Bytes_(), this.getBextBytes_(), this.getiXMLBytes_(), this.getFmtBytes_(), this.getFactBytes_(), packString(this.data.chunkId), pack(this.data.samples.length, this.uInt32), this.data.samples, this.getCueBytes_(), this.getSmplBytes_(), this.getLISTBytes_(), this.get_PMXBytes_()];\n      /** @type {number} */\n\n      var fileBodyLength = 0;\n\n      for (var i = 0; i < fileBody.length; i++) {\n        fileBodyLength += fileBody[i].length;\n      }\n      /** @type {!Uint8Array} */\n\n\n      var file = new Uint8Array(fileBodyLength + 12);\n      /** @type {number} */\n\n      var index = 0;\n      index = packStringTo(this.container, file, index);\n      index = packTo(fileBodyLength + 4, this.uInt32, file, index);\n      index = packStringTo(this.format, file, index);\n\n      for (var _i = 0; _i < fileBody.length; _i++) {\n        file.set(fileBody[_i], index);\n        index += fileBody[_i].length;\n      }\n\n      return file;\n    }\n    /**\r\n     * Return the bytes of the 'bext' chunk.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getBextBytes_\",\n    value: function getBextBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n      this.enforceBext_();\n\n      if (this.bext.chunkId) {\n        this.bext.chunkSize = 602 + this.bext.codingHistory.length;\n        bytes = bytes.concat(packString(this.bext.chunkId), pack(602 + this.bext.codingHistory.length, this.uInt32), writeString(this.bext.description, 256), writeString(this.bext.originator, 32), writeString(this.bext.originatorReference, 32), writeString(this.bext.originationDate, 10), writeString(this.bext.originationTime, 8), pack(this.bext.timeReference[0], this.uInt32), pack(this.bext.timeReference[1], this.uInt32), pack(this.bext.version, this.uInt16), writeString(this.bext.UMID, 64), pack(this.bext.loudnessValue, this.uInt16), pack(this.bext.loudnessRange, this.uInt16), pack(this.bext.maxTruePeakLevel, this.uInt16), pack(this.bext.maxMomentaryLoudness, this.uInt16), pack(this.bext.maxShortTermLoudness, this.uInt16), writeString(this.bext.reserved, 180), writeString(this.bext.codingHistory, this.bext.codingHistory.length));\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"enforceBext_\",\n    value: function enforceBext_() {\n      for (var prop in this.bext) {\n        if (this.bext.hasOwnProperty(prop)) {\n          if (this.bext[prop] && prop != 'timeReference') {\n            this.bext.chunkId = 'bext';\n            break;\n          }\n        }\n      }\n\n      if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\n        this.bext.chunkId = 'bext';\n      }\n    }\n    /**\r\n     * Return the bytes of the 'iXML' chunk.\r\n     * @return {!Array<number>} The 'iXML' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getiXMLBytes_\",\n    value: function getiXMLBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this.iXML.chunkId) {\n        /** @type {!Array<number>} */\n        var iXMLPackedValue = packString(this.iXML.value);\n        this.iXML.chunkSize = iXMLPackedValue.length;\n        bytes = bytes.concat(packString(this.iXML.chunkId), pack(this.iXML.chunkSize, this.uInt32), iXMLPackedValue);\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the 'ds64' chunk.\r\n     * @return {!Array<number>} The 'ds64' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getDs64Bytes_\",\n    value: function getDs64Bytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this.ds64.chunkId) {\n        bytes = bytes.concat(packString(this.ds64.chunkId), pack(this.ds64.chunkSize, this.uInt32), pack(this.ds64.riffSizeHigh, this.uInt32), pack(this.ds64.riffSizeLow, this.uInt32), pack(this.ds64.dataSizeHigh, this.uInt32), pack(this.ds64.dataSizeLow, this.uInt32), pack(this.ds64.originationTime, this.uInt32), pack(this.ds64.sampleCountHigh, this.uInt32), pack(this.ds64.sampleCountLow, this.uInt32));\n      } //if (this.ds64.tableLength) {\n      //  ds64Bytes = ds64Bytes.concat(\n      //    pack(this.ds64.tableLength, this.uInt32),\n      //    this.ds64.table);\n      //}\n\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the 'cue ' chunk.\r\n     * @return {!Array<number>} The 'cue ' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getCueBytes_\",\n    value: function getCueBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this.cue.chunkId) {\n        /** @type {!Array<number>} */\n        var cuePointsBytes = this.getCuePointsBytes_();\n        bytes = bytes.concat(packString(this.cue.chunkId), pack(cuePointsBytes.length + 4, this.uInt32), // chunkSize\n        pack(this.cue.dwCuePoints, this.uInt32), cuePointsBytes);\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the 'cue ' points.\r\n     * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getCuePointsBytes_\",\n    value: function getCuePointsBytes_() {\n      /** @type {!Array<number>} */\n      var points = [];\n\n      for (var i = 0; i < this.cue.dwCuePoints; i++) {\n        points = points.concat(pack(this.cue.points[i].dwName, this.uInt32), pack(this.cue.points[i].dwPosition, this.uInt32), packString(this.cue.points[i].fccChunk), pack(this.cue.points[i].dwChunkStart, this.uInt32), pack(this.cue.points[i].dwBlockStart, this.uInt32), pack(this.cue.points[i].dwSampleOffset, this.uInt32));\n      }\n\n      return points;\n    }\n    /**\r\n     * Return the bytes of the 'smpl' chunk.\r\n     * @return {!Array<number>} The 'smpl' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getSmplBytes_\",\n    value: function getSmplBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this.smpl.chunkId) {\n        /** @type {!Array<number>} */\n        var smplLoopsBytes = this.getSmplLoopsBytes_();\n        bytes = bytes.concat(packString(this.smpl.chunkId), pack(smplLoopsBytes.length + 36, this.uInt32), //chunkSize\n        pack(this.smpl.dwManufacturer, this.uInt32), pack(this.smpl.dwProduct, this.uInt32), pack(this.smpl.dwSamplePeriod, this.uInt32), pack(this.smpl.dwMIDIUnityNote, this.uInt32), pack(this.smpl.dwMIDIPitchFraction, this.uInt32), pack(this.smpl.dwSMPTEFormat, this.uInt32), pack(this.smpl.dwSMPTEOffset, this.uInt32), pack(this.smpl.dwNumSampleLoops, this.uInt32), pack(this.smpl.dwSamplerData, this.uInt32), smplLoopsBytes);\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the 'smpl' loops.\r\n     * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getSmplLoopsBytes_\",\n    value: function getSmplLoopsBytes_() {\n      /** @type {!Array<number>} */\n      var loops = [];\n\n      for (var i = 0; i < this.smpl.dwNumSampleLoops; i++) {\n        loops = loops.concat(pack(this.smpl.loops[i].dwName, this.uInt32), pack(this.smpl.loops[i].dwType, this.uInt32), pack(this.smpl.loops[i].dwStart, this.uInt32), pack(this.smpl.loops[i].dwEnd, this.uInt32), pack(this.smpl.loops[i].dwFraction, this.uInt32), pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\n      }\n\n      return loops;\n    }\n    /**\r\n     * Return the bytes of the 'fact' chunk.\r\n     * @return {!Array<number>} The 'fact' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getFactBytes_\",\n    value: function getFactBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this.fact.chunkId) {\n        bytes = bytes.concat(packString(this.fact.chunkId), pack(this.fact.chunkSize, this.uInt32), pack(this.fact.dwSampleLength, this.uInt32));\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the 'fmt ' chunk.\r\n     * @return {!Array<number>} The 'fmt' chunk bytes.\r\n     * @throws {Error} if no 'fmt ' chunk is present.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getFmtBytes_\",\n    value: function getFmtBytes_() {\n      /** @type {!Array<number>} */\n      var fmtBytes = [];\n\n      if (this.fmt.chunkId) {\n        /** @type {!Array<number>} */\n        var bytes = fmtBytes.concat(packString(this.fmt.chunkId), pack(this.fmt.chunkSize, this.uInt32), pack(this.fmt.audioFormat, this.uInt16), pack(this.fmt.numChannels, this.uInt16), pack(this.fmt.sampleRate, this.uInt32), pack(this.fmt.byteRate, this.uInt32), pack(this.fmt.blockAlign, this.uInt16), pack(this.fmt.bitsPerSample, this.uInt16), this.getFmtExtensionBytes_());\n        this.enforceByteLen_(bytes);\n        return bytes;\n      }\n\n      throw Error('Could not find the \"fmt \" chunk');\n    }\n    /**\r\n     * Return the bytes of the fmt extension fields.\r\n     * @return {!Array<number>} The fmt extension bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getFmtExtensionBytes_\",\n    value: function getFmtExtensionBytes_() {\n      /** @type {!Array<number>} */\n      var extension = [];\n\n      if (this.fmt.chunkSize > 16) {\n        extension = extension.concat(pack(this.fmt.cbSize, this.uInt16));\n      }\n\n      if (this.fmt.chunkSize > 18) {\n        extension = extension.concat(pack(this.fmt.validBitsPerSample, this.uInt16));\n      }\n\n      if (this.fmt.chunkSize > 20) {\n        extension = extension.concat(pack(this.fmt.dwChannelMask, this.uInt32));\n      }\n\n      if (this.fmt.chunkSize > 24) {\n        extension = extension.concat(pack(this.fmt.subformat[0], this.uInt32), pack(this.fmt.subformat[1], this.uInt32), pack(this.fmt.subformat[2], this.uInt32), pack(this.fmt.subformat[3], this.uInt32));\n      }\n\n      return extension;\n    }\n    /**\r\n     * Return the bytes of the 'LIST' chunk.\r\n     * @return {!Array<number>} The 'LIST' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getLISTBytes_\",\n    value: function getLISTBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      for (var i = 0; i < this.LIST.length; i++) {\n        /** @type {!Array<number>} */\n        var subChunksBytes = this.getLISTSubChunksBytes_(this.LIST[i].subChunks, this.LIST[i].format);\n        bytes = bytes.concat(packString(this.LIST[i].chunkId), pack(subChunksBytes.length + 4, this.uInt32), //chunkSize\n        packString(this.LIST[i].format), subChunksBytes);\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n     * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n     * @param {string} format The format of the 'LIST' chunk.\r\n     *    Currently supported values are 'adtl' or 'INFO'.\r\n     * @return {!Array<number>} The sub chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getLISTSubChunksBytes_\",\n    value: function getLISTSubChunksBytes_(subChunks, format) {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      for (var i = 0, len = subChunks.length; i < len; i++) {\n        if (format == 'INFO') {\n          bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\n        } else if (format == 'adtl') {\n          bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\n        }\n\n        this.enforceByteLen_(bytes);\n      }\n\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n     * @param {!Object} subChunk The 'LIST' sub chunk.\r\n     * @return {!Array<number>}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getLISTINFOSubChunksBytes_\",\n    value: function getLISTINFOSubChunksBytes_(subChunk) {\n      /** @type {!Array<number>} */\n      var bytes = [];\n      /** @type {!Array<number>} */\n\n      var LISTsubChunkValue = writeString(subChunk.value, subChunk.value.length);\n      bytes = bytes.concat(packString(subChunk.chunkId), pack(LISTsubChunkValue.length + 1, this.uInt32), //chunkSize\n      LISTsubChunkValue);\n      bytes.push(0);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n     * @param {!Object} subChunk The 'LIST' sub chunk.\r\n     * @return {!Array<number>}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getLISTadtlSubChunksBytes_\",\n    value: function getLISTadtlSubChunksBytes_(subChunk) {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\n        /** @type {!Array<number>} */\n        var LISTsubChunkValue = writeString(subChunk.value, subChunk.value.length);\n        bytes = bytes.concat(packString(subChunk.chunkId), pack(LISTsubChunkValue.length + 4 + 1, this.uInt32), //chunkSize\n        pack(subChunk.dwName, this.uInt32), LISTsubChunkValue);\n        bytes.push(0);\n      } else if (subChunk.chunkId == 'ltxt') {\n        bytes = bytes.concat(this.getLtxtChunkBytes_(subChunk));\n      }\n\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of a 'ltxt' chunk.\r\n     * @param {!Object} ltxt the 'ltxt' chunk.\r\n     * @return {!Array<number>}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getLtxtChunkBytes_\",\n    value: function getLtxtChunkBytes_(ltxt) {\n      return [].concat(packString(ltxt.chunkId), pack(ltxt.value.length + 20, this.uInt32), pack(ltxt.dwName, this.uInt32), pack(ltxt.dwSampleLength, this.uInt32), pack(ltxt.dwPurposeID, this.uInt32), pack(ltxt.dwCountry, this.uInt16), pack(ltxt.dwLanguage, this.uInt16), pack(ltxt.dwDialect, this.uInt16), pack(ltxt.dwCodePage, this.uInt16), // should always be a empty string;\n      // kept for compatibility\n      writeString(ltxt.value, ltxt.value.length));\n    }\n    /**\r\n     * Return the bytes of the '_PMX' chunk.\r\n     * @return {!Array<number>} The '_PMX' chunk bytes.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"get_PMXBytes_\",\n    value: function get_PMXBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this._PMX.chunkId) {\n        /** @type {!Array<number>} */\n        var _PMXPackedValue = packString(this._PMX.value);\n\n        this._PMX.chunkSize = _PMXPackedValue.length;\n        bytes = bytes.concat(packString(this._PMX.chunkId), pack(this._PMX.chunkSize, this.uInt32), _PMXPackedValue);\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Return the bytes of the 'junk' chunk.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getJunkBytes_\",\n    value: function getJunkBytes_() {\n      /** @type {!Array<number>} */\n      var bytes = [];\n\n      if (this.junk.chunkId) {\n        return bytes.concat(packString(this.junk.chunkId), pack(this.junk.chunkData.length, this.uInt32), //chunkSize\n        this.junk.chunkData);\n      }\n\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    /**\r\n     * Push a null byte into a byte array if\r\n     * the byte count is odd.\r\n     * @param {!Array<number>} bytes The byte array.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"enforceByteLen_\",\n    value: function enforceByteLen_(bytes) {\n      if (bytes.length % 2) {\n        bytes.push(0);\n      }\n    }\n  }]);\n\n  return WaveFileParser;\n}(WaveFileReader);","map":{"version":3,"sources":["/Users/eric/test/herokutestcs/my-app/node_modules/wavefile/lib/wavefile-parser.js"],"names":["WaveFileReader","writeString","packTo","packStringTo","packString","pack","WaveFileParser","uInt16","be","container","uInt32","fileBody","getJunkBytes_","getDs64Bytes_","getBextBytes_","getiXMLBytes_","getFmtBytes_","getFactBytes_","data","chunkId","samples","length","getCueBytes_","getSmplBytes_","getLISTBytes_","get_PMXBytes_","fileBodyLength","i","file","Uint8Array","index","format","set","bytes","enforceBext_","bext","chunkSize","codingHistory","concat","description","originator","originatorReference","originationDate","originationTime","timeReference","version","UMID","loudnessValue","loudnessRange","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","reserved","enforceByteLen_","prop","hasOwnProperty","iXML","iXMLPackedValue","value","ds64","riffSizeHigh","riffSizeLow","dataSizeHigh","dataSizeLow","sampleCountHigh","sampleCountLow","cue","cuePointsBytes","getCuePointsBytes_","dwCuePoints","points","dwName","dwPosition","fccChunk","dwChunkStart","dwBlockStart","dwSampleOffset","smpl","smplLoopsBytes","getSmplLoopsBytes_","dwManufacturer","dwProduct","dwSamplePeriod","dwMIDIUnityNote","dwMIDIPitchFraction","dwSMPTEFormat","dwSMPTEOffset","dwNumSampleLoops","dwSamplerData","loops","dwType","dwStart","dwEnd","dwFraction","dwPlayCount","fact","dwSampleLength","fmtBytes","fmt","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","getFmtExtensionBytes_","Error","extension","cbSize","validBitsPerSample","dwChannelMask","subformat","LIST","subChunksBytes","getLISTSubChunksBytes_","subChunks","len","getLISTINFOSubChunksBytes_","getLISTadtlSubChunksBytes_","subChunk","LISTsubChunkValue","push","indexOf","getLtxtChunkBytes_","ltxt","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","_PMX","_PMXPackedValue","junk","chunkData"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileReader } from './wavefile-reader';\r\nimport { writeString } from './parsers/write-string';\r\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\r\nexport class WaveFileParser extends WaveFileReader {\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   */\r\n  toBuffer() {\r\n    this.uInt16.be = this.container === 'RIFX';\r\n    this.uInt32.be = this.uInt16.be;\r\n    /** @type {!Array<!Array<number>>} */\r\n    let fileBody = [\r\n      this.getJunkBytes_(),\r\n      this.getDs64Bytes_(),\r\n      this.getBextBytes_(),\r\n      this.getiXMLBytes_(),\r\n      this.getFmtBytes_(),\r\n      this.getFactBytes_(),\r\n      packString(this.data.chunkId),\r\n      pack(this.data.samples.length, this.uInt32),\r\n      this.data.samples,\r\n      this.getCueBytes_(),\r\n      this.getSmplBytes_(),\r\n      this.getLISTBytes_(),\r\n      this.get_PMXBytes_()\r\n    ];\r\n    /** @type {number} */\r\n    let fileBodyLength = 0;\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      fileBodyLength += fileBody[i].length;\r\n    }\r\n    /** @type {!Uint8Array} */\r\n    let file = new Uint8Array(fileBodyLength + 12);\r\n    /** @type {number} */\r\n    let index = 0;\r\n    index = packStringTo(this.container, file, index);\r\n    index = packTo(fileBodyLength + 4, this.uInt32, file, index);\r\n    index = packStringTo(this.format, file, index);\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      file.set(fileBody[i], index);\r\n      index += fileBody[i].length;\r\n    }\r\n    return file;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @private\r\n   */\r\n  getBextBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    this.enforceBext_();\r\n    if (this.bext.chunkId) {\r\n      this.bext.chunkSize = 602 + this.bext.codingHistory.length;\r\n      bytes = bytes.concat(\r\n        packString(this.bext.chunkId),\r\n        pack(602 + this.bext.codingHistory.length, this.uInt32),\r\n        writeString(this.bext.description, 256),\r\n        writeString(this.bext.originator, 32),\r\n        writeString(this.bext.originatorReference, 32),\r\n        writeString(this.bext.originationDate, 10),\r\n        writeString(this.bext.originationTime, 8),\r\n        pack(this.bext.timeReference[0], this.uInt32),\r\n        pack(this.bext.timeReference[1], this.uInt32),\r\n        pack(this.bext.version, this.uInt16),\r\n        writeString(this.bext.UMID, 64),\r\n        pack(this.bext.loudnessValue, this.uInt16),\r\n        pack(this.bext.loudnessRange, this.uInt16),\r\n        pack(this.bext.maxTruePeakLevel, this.uInt16),\r\n        pack(this.bext.maxMomentaryLoudness, this.uInt16),\r\n        pack(this.bext.maxShortTermLoudness, this.uInt16),\r\n        writeString(this.bext.reserved, 180),\r\n        writeString(\r\n          this.bext.codingHistory, this.bext.codingHistory.length));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\r\n  enforceBext_() {\r\n    for (let prop in this.bext) {\r\n      if (this.bext.hasOwnProperty(prop)) {\r\n        if (this.bext[prop] && prop != 'timeReference') {\r\n          this.bext.chunkId = 'bext';\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\r\n      this.bext.chunkId = 'bext';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'iXML' chunk.\r\n   * @return {!Array<number>} The 'iXML' chunk bytes.\r\n   * @private\r\n   */\r\n  getiXMLBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.iXML.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let iXMLPackedValue = packString(this.iXML.value);\r\n      this.iXML.chunkSize = iXMLPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this.iXML.chunkId),\r\n        pack(this.iXML.chunkSize, this.uInt32),\r\n        iXMLPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\r\n  getDs64Bytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.ds64.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.ds64.chunkId),\r\n        pack(this.ds64.chunkSize, this.uInt32),\r\n        pack(this.ds64.riffSizeHigh, this.uInt32),\r\n        pack(this.ds64.riffSizeLow, this.uInt32),\r\n        pack(this.ds64.dataSizeHigh, this.uInt32),\r\n        pack(this.ds64.dataSizeLow, this.uInt32),\r\n        pack(this.ds64.originationTime, this.uInt32),\r\n        pack(this.ds64.sampleCountHigh, this.uInt32),\r\n        pack(this.ds64.sampleCountLow, this.uInt32));\r\n    }\r\n    //if (this.ds64.tableLength) {\r\n    //  ds64Bytes = ds64Bytes.concat(\r\n    //    pack(this.ds64.tableLength, this.uInt32),\r\n    //    this.ds64.table);\r\n    //}\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\r\n  getCueBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.cue.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let cuePointsBytes = this.getCuePointsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.cue.chunkId),\r\n        pack(cuePointsBytes.length + 4, this.uInt32), // chunkSize\r\n        pack(this.cue.dwCuePoints, this.uInt32),\r\n        cuePointsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\r\n  getCuePointsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n      points = points.concat(\r\n        pack(this.cue.points[i].dwName, this.uInt32),\r\n        pack(this.cue.points[i].dwPosition, this.uInt32),\r\n        packString(this.cue.points[i].fccChunk),\r\n        pack(this.cue.points[i].dwChunkStart, this.uInt32),\r\n        pack(this.cue.points[i].dwBlockStart, this.uInt32),\r\n        pack(this.cue.points[i].dwSampleOffset, this.uInt32));\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\r\n  getSmplBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.smpl.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.smpl.chunkId),\r\n        pack(smplLoopsBytes.length + 36, this.uInt32), //chunkSize\r\n        pack(this.smpl.dwManufacturer, this.uInt32),\r\n        pack(this.smpl.dwProduct, this.uInt32),\r\n        pack(this.smpl.dwSamplePeriod, this.uInt32),\r\n        pack(this.smpl.dwMIDIUnityNote, this.uInt32),\r\n        pack(this.smpl.dwMIDIPitchFraction, this.uInt32),\r\n        pack(this.smpl.dwSMPTEFormat, this.uInt32),\r\n        pack(this.smpl.dwSMPTEOffset, this.uInt32),\r\n        pack(this.smpl.dwNumSampleLoops, this.uInt32),\r\n        pack(this.smpl.dwSamplerData, this.uInt32),\r\n        smplLoopsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\r\n  getSmplLoopsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let loops = [];\r\n    for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n      loops = loops.concat(\r\n        pack(this.smpl.loops[i].dwName, this.uInt32),\r\n        pack(this.smpl.loops[i].dwType, this.uInt32),\r\n        pack(this.smpl.loops[i].dwStart, this.uInt32),\r\n        pack(this.smpl.loops[i].dwEnd, this.uInt32),\r\n        pack(this.smpl.loops[i].dwFraction, this.uInt32),\r\n        pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\r\n    }\r\n    return loops;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\r\n  getFactBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.fact.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.fact.chunkId),\r\n        pack(this.fact.chunkSize, this.uInt32),\r\n        pack(this.fact.dwSampleLength, this.uInt32));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\r\n  getFmtBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let fmtBytes = [];\r\n    if (this.fmt.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let bytes  = fmtBytes.concat(\r\n        packString(this.fmt.chunkId),\r\n        pack(this.fmt.chunkSize, this.uInt32),\r\n        pack(this.fmt.audioFormat, this.uInt16),\r\n        pack(this.fmt.numChannels, this.uInt16),\r\n        pack(this.fmt.sampleRate, this.uInt32),\r\n        pack(this.fmt.byteRate, this.uInt32),\r\n        pack(this.fmt.blockAlign, this.uInt16),\r\n        pack(this.fmt.bitsPerSample, this.uInt16),\r\n        this.getFmtExtensionBytes_());\r\n      this.enforceByteLen_(bytes);\r\n      return bytes;\r\n    }\r\n    throw Error('Could not find the \"fmt \" chunk');\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\r\n  getFmtExtensionBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let extension = [];\r\n    if (this.fmt.chunkSize > 16) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.cbSize, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 18) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.validBitsPerSample, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 20) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.dwChannelMask, this.uInt32));\r\n    }\r\n    if (this.fmt.chunkSize > 24) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.subformat[0], this.uInt32),\r\n        pack(this.fmt.subformat[1], this.uInt32),\r\n        pack(this.fmt.subformat[2], this.uInt32),\r\n        pack(this.fmt.subformat[3], this.uInt32));\r\n    }\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      /** @type {!Array<number>} */\r\n      let subChunksBytes = this.getLISTSubChunksBytes_(\r\n          this.LIST[i].subChunks, this.LIST[i].format);\r\n      bytes = bytes.concat(\r\n        packString(this.LIST[i].chunkId),\r\n        pack(subChunksBytes.length + 4, this.uInt32), //chunkSize\r\n        packString(this.LIST[i].format),\r\n        subChunksBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTSubChunksBytes_(subChunks, format) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i = 0, len = subChunks.length; i < len; i++) {\r\n      if (format == 'INFO') {\r\n        bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\r\n      } else if (format == 'adtl') {\r\n        bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\r\n      }\r\n      this.enforceByteLen_(bytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTINFOSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    /** @type {!Array<number>} */\r\n    let LISTsubChunkValue = writeString(\r\n        subChunk.value, subChunk.value.length);\r\n    bytes = bytes.concat(\r\n      packString(subChunk.chunkId),\r\n      pack(LISTsubChunkValue.length + 1, this.uInt32), //chunkSize\r\n      LISTsubChunkValue);\r\n    bytes.push(0);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTadtlSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\r\n      /** @type {!Array<number>} */\r\n      let LISTsubChunkValue = writeString(\r\n          subChunk.value,\r\n          subChunk.value.length);\r\n      bytes = bytes.concat(\r\n        packString(subChunk.chunkId),\r\n        pack(LISTsubChunkValue.length + 4 + 1, this.uInt32), //chunkSize\r\n        pack(subChunk.dwName, this.uInt32),\r\n        LISTsubChunkValue);\r\n      bytes.push(0);\r\n    } else if (subChunk.chunkId == 'ltxt') {\r\n      bytes = bytes.concat(\r\n        this.getLtxtChunkBytes_(subChunk));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLtxtChunkBytes_(ltxt) {\r\n    return [].concat(\r\n      packString(ltxt.chunkId),\r\n      pack(ltxt.value.length + 20, this.uInt32),\r\n      pack(ltxt.dwName, this.uInt32),\r\n      pack(ltxt.dwSampleLength, this.uInt32),\r\n      pack(ltxt.dwPurposeID, this.uInt32),\r\n      pack(ltxt.dwCountry, this.uInt16),\r\n      pack(ltxt.dwLanguage, this.uInt16),\r\n      pack(ltxt.dwDialect, this.uInt16),\r\n      pack(ltxt.dwCodePage, this.uInt16),\r\n       // should always be a empty string;\r\n       // kept for compatibility\r\n      writeString(ltxt.value, ltxt.value.length));\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the '_PMX' chunk.\r\n   * @return {!Array<number>} The '_PMX' chunk bytes.\r\n   * @private\r\n   */\r\n  get_PMXBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this._PMX.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let _PMXPackedValue = packString(this._PMX.value);\r\n      this._PMX.chunkSize = _PMXPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this._PMX.chunkId),\r\n        pack(this._PMX.chunkSize, this.uInt32),\r\n        _PMXPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @private\r\n   */\r\n  getJunkBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.junk.chunkId) {\r\n      return bytes.concat(\r\n        packString(this.junk.chunkId),\r\n        pack(this.junk.chunkData.length, this.uInt32), //chunkSize\r\n        this.junk.chunkData);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Push a null byte into a byte array if\r\n   * the byte count is odd.\r\n   * @param {!Array<number>} bytes The byte array.\r\n   * @private\r\n   */\r\n  enforceByteLen_(bytes) {\r\n    if (bytes.length % 2) {\r\n      bytes.push(0);\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}