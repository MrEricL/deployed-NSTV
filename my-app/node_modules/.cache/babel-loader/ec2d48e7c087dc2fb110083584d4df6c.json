{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { RIFFFile } from './riff-file';\nimport { unpackString, unpack } from './parsers/binary';\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\n\nexport var WaveFileReader = /*#__PURE__*/function (_RIFFFile) {\n  _inherits(WaveFileReader, _RIFFFile);\n\n  var _super = _createSuper(WaveFileReader);\n\n  function WaveFileReader() {\n    var _this;\n\n    _classCallCheck(this, WaveFileReader);\n\n    _this = _super.call(this); // Include 'RF64' as a supported container format\n\n    _this.supported_containers.push('RF64');\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n\n    _this.fmt = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      audioFormat: 0,\n\n      /** @type {number} */\n      numChannels: 0,\n\n      /** @type {number} */\n      sampleRate: 0,\n\n      /** @type {number} */\n      byteRate: 0,\n\n      /** @type {number} */\n      blockAlign: 0,\n\n      /** @type {number} */\n      bitsPerSample: 0,\n\n      /** @type {number} */\n      cbSize: 0,\n\n      /** @type {number} */\n      validBitsPerSample: 0,\n\n      /** @type {number} */\n      dwChannelMask: 0,\n\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\n      subformat: []\n    };\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.fact = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      dwSampleLength: 0\n    };\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.cue = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      dwCuePoints: 0,\n\n      /** @type {!Array<!Object>} */\n      points: []\n    };\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.smpl = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      dwManufacturer: 0,\n\n      /** @type {number} */\n      dwProduct: 0,\n\n      /** @type {number} */\n      dwSamplePeriod: 0,\n\n      /** @type {number} */\n      dwMIDIUnityNote: 0,\n\n      /** @type {number} */\n      dwMIDIPitchFraction: 0,\n\n      /** @type {number} */\n      dwSMPTEFormat: 0,\n\n      /** @type {number} */\n      dwSMPTEOffset: 0,\n\n      /** @type {number} */\n      dwNumSampleLoops: 0,\n\n      /** @type {number} */\n      dwSamplerData: 0,\n\n      /** @type {!Array<!Object>} */\n      loops: []\n    };\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.bext = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {string} */\n      description: '',\n      //256\n\n      /** @type {string} */\n      originator: '',\n      //32\n\n      /** @type {string} */\n      originatorReference: '',\n      //32\n\n      /** @type {string} */\n      originationDate: '',\n      //10\n\n      /** @type {string} */\n      originationTime: '',\n      //8\n\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\n      timeReference: [0, 0],\n\n      /** @type {number} */\n      version: 0,\n      //WORD\n\n      /** @type {string} */\n      UMID: '',\n      // 64 chars\n\n      /** @type {number} */\n      loudnessValue: 0,\n      //WORD\n\n      /** @type {number} */\n      loudnessRange: 0,\n      //WORD\n\n      /** @type {number} */\n      maxTruePeakLevel: 0,\n      //WORD\n\n      /** @type {number} */\n      maxMomentaryLoudness: 0,\n      //WORD\n\n      /** @type {number} */\n      maxShortTermLoudness: 0,\n      //WORD\n\n      /** @type {string} */\n      reserved: '',\n      //180\n\n      /** @type {string} */\n      codingHistory: '' // string, unlimited\n\n    };\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.iXML = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {string} */\n      value: ''\n    };\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.ds64 = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {number} */\n      riffSizeHigh: 0,\n      // DWORD\n\n      /** @type {number} */\n      riffSizeLow: 0,\n      // DWORD\n\n      /** @type {number} */\n      dataSizeHigh: 0,\n      // DWORD\n\n      /** @type {number} */\n      dataSizeLow: 0,\n      // DWORD\n\n      /** @type {number} */\n      originationTime: 0,\n      // DWORD\n\n      /** @type {number} */\n      sampleCountHigh: 0,\n      // DWORD\n\n      /** @type {number} */\n      sampleCountLow: 0 // DWORD\n\n      /** @type {number} */\n      //'tableLength': 0, // DWORD\n\n      /** @type {!Array<number>} */\n      //'table': []\n\n    };\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.data = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {!Uint8Array} */\n      samples: new Uint8Array(0)\n    };\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\n\n    _this.LIST = [];\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this.junk = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {!Array<number>} */\n      chunkData: []\n    };\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n\n    _this._PMX = {\n      /** @type {string} */\n      chunkId: '',\n\n      /** @type {number} */\n      chunkSize: 0,\n\n      /** @type {string} */\n      value: ''\n    };\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\n\n    _this.uInt16 = {\n      bits: 16,\n      be: false,\n      signed: false,\n      fp: false\n    };\n    return _this;\n  }\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\n\n\n  _createClass(WaveFileReader, [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(wavBuffer) {\n      var samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // Always should reset the chunks when reading from a buffer\n      this.clearHeaders();\n      this.setSignature(wavBuffer);\n      this.uInt16.be = this.uInt32.be;\n\n      if (this.format != 'WAVE') {\n        throw Error('Could not find the \"WAVE\" format identifier');\n      }\n\n      this.readDs64Chunk_(wavBuffer);\n      this.readFmtChunk_(wavBuffer);\n      this.readFactChunk_(wavBuffer);\n      this.readBextChunk_(wavBuffer);\n      this.readiXMLChunk_(wavBuffer);\n      this.readCueChunk_(wavBuffer);\n      this.readSmplChunk_(wavBuffer);\n      this.readDataChunk_(wavBuffer, samples);\n      this.readJunkChunk_(wavBuffer);\n      this.readLISTChunk_(wavBuffer);\n      this.read_PMXChunk_(wavBuffer);\n    }\n    /**\r\n     * Reset the chunks of the WaveFileReader instance.\r\n     * @protected\r\n     * @ignore\r\n     */\n\n  }, {\n    key: \"clearHeaders\",\n    value: function clearHeaders() {\n      /** @type {!Object} */\n      var tmpWav = new WaveFileReader();\n      Object.assign(this.fmt, tmpWav.fmt);\n      Object.assign(this.fact, tmpWav.fact);\n      Object.assign(this.cue, tmpWav.cue);\n      Object.assign(this.smpl, tmpWav.smpl);\n      Object.assign(this.bext, tmpWav.bext);\n      Object.assign(this.iXML, tmpWav.iXML);\n      Object.assign(this.ds64, tmpWav.ds64);\n      Object.assign(this.data, tmpWav.data);\n      this.LIST = [];\n      Object.assign(this.junk, tmpWav.junk);\n      Object.assign(this._PMX, tmpWav._PMX);\n    }\n    /**\r\n     * Read the 'fmt ' chunk of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @throws {Error} If no 'fmt ' chunk is found.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readFmtChunk_\",\n    value: function readFmtChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('fmt ');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.fmt.chunkId = chunk.chunkId;\n        this.fmt.chunkSize = chunk.chunkSize;\n        this.fmt.audioFormat = this.readUInt16_(buffer);\n        this.fmt.numChannels = this.readUInt16_(buffer);\n        this.fmt.sampleRate = this.readUInt32(buffer);\n        this.fmt.byteRate = this.readUInt32(buffer);\n        this.fmt.blockAlign = this.readUInt16_(buffer);\n        this.fmt.bitsPerSample = this.readUInt16_(buffer);\n        this.readFmtExtension_(buffer);\n      } else {\n        throw Error('Could not find the \"fmt \" chunk');\n      }\n    }\n    /**\r\n     * Read the 'fmt ' chunk extension.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readFmtExtension_\",\n    value: function readFmtExtension_(buffer) {\n      if (this.fmt.chunkSize > 16) {\n        this.fmt.cbSize = this.readUInt16_(buffer);\n\n        if (this.fmt.chunkSize > 18) {\n          this.fmt.validBitsPerSample = this.readUInt16_(buffer);\n\n          if (this.fmt.chunkSize > 20) {\n            this.fmt.dwChannelMask = this.readUInt32(buffer);\n            this.fmt.subformat = [this.readUInt32(buffer), this.readUInt32(buffer), this.readUInt32(buffer), this.readUInt32(buffer)];\n          }\n        }\n      }\n    }\n    /**\r\n     * Read the 'fact' chunk of a wav file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readFactChunk_\",\n    value: function readFactChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('fact');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.fact.chunkId = chunk.chunkId;\n        this.fact.chunkSize = chunk.chunkSize;\n        this.fact.dwSampleLength = this.readUInt32(buffer);\n      }\n    }\n    /**\r\n     * Read the 'cue ' chunk of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readCueChunk_\",\n    value: function readCueChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('cue ');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.cue.chunkId = chunk.chunkId;\n        this.cue.chunkSize = chunk.chunkSize;\n        this.cue.dwCuePoints = this.readUInt32(buffer);\n\n        for (var i = 0; i < this.cue.dwCuePoints; i++) {\n          this.cue.points.push({\n            dwName: this.readUInt32(buffer),\n            dwPosition: this.readUInt32(buffer),\n            fccChunk: this.readString(buffer, 4),\n            dwChunkStart: this.readUInt32(buffer),\n            dwBlockStart: this.readUInt32(buffer),\n            dwSampleOffset: this.readUInt32(buffer)\n          });\n        }\n      }\n    }\n    /**\r\n     * Read the 'smpl' chunk of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readSmplChunk_\",\n    value: function readSmplChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('smpl');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.smpl.chunkId = chunk.chunkId;\n        this.smpl.chunkSize = chunk.chunkSize;\n        this.smpl.dwManufacturer = this.readUInt32(buffer);\n        this.smpl.dwProduct = this.readUInt32(buffer);\n        this.smpl.dwSamplePeriod = this.readUInt32(buffer);\n        this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\n        this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\n        this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\n        this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\n        this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\n        this.smpl.dwSamplerData = this.readUInt32(buffer);\n\n        for (var i = 0; i < this.smpl.dwNumSampleLoops; i++) {\n          this.smpl.loops.push({\n            dwName: this.readUInt32(buffer),\n            dwType: this.readUInt32(buffer),\n            dwStart: this.readUInt32(buffer),\n            dwEnd: this.readUInt32(buffer),\n            dwFraction: this.readUInt32(buffer),\n            dwPlayCount: this.readUInt32(buffer)\n          });\n        }\n      }\n    }\n    /**\r\n     * Read the 'data' chunk of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @param {boolean} samples True if the samples should be loaded.\r\n     * @throws {Error} If no 'data' chunk is found.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readDataChunk_\",\n    value: function readDataChunk_(buffer, samples) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('data');\n\n      if (chunk) {\n        this.data.chunkId = 'data';\n        this.data.chunkSize = chunk.chunkSize;\n\n        if (samples) {\n          this.data.samples = buffer.slice(chunk.chunkData.start, chunk.chunkData.end);\n        }\n      } else {\n        throw Error('Could not find the \"data\" chunk');\n      }\n    }\n    /**\r\n     * Read the 'bext' chunk of a wav file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readBextChunk_\",\n    value: function readBextChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('bext');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.bext.chunkId = chunk.chunkId;\n        this.bext.chunkSize = chunk.chunkSize;\n        this.bext.description = this.readString(buffer, 256);\n        this.bext.originator = this.readString(buffer, 32);\n        this.bext.originatorReference = this.readString(buffer, 32);\n        this.bext.originationDate = this.readString(buffer, 10);\n        this.bext.originationTime = this.readString(buffer, 8);\n        this.bext.timeReference = [this.readUInt32(buffer), this.readUInt32(buffer)];\n        this.bext.version = this.readUInt16_(buffer);\n        this.bext.UMID = this.readString(buffer, 64);\n        this.bext.loudnessValue = this.readUInt16_(buffer);\n        this.bext.loudnessRange = this.readUInt16_(buffer);\n        this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\n        this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\n        this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\n        this.bext.reserved = this.readString(buffer, 180);\n        this.bext.codingHistory = this.readString(buffer, this.bext.chunkSize - 602);\n      }\n    }\n    /**\r\n     * Read the 'iXML' chunk of a wav file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readiXMLChunk_\",\n    value: function readiXMLChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('iXML');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.iXML.chunkId = chunk.chunkId;\n        this.iXML.chunkSize = chunk.chunkSize;\n        this.iXML.value = unpackString(buffer, this.head, this.head + this.iXML.chunkSize);\n      }\n    }\n    /**\r\n     * Read the 'ds64' chunk of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readDs64Chunk_\",\n    value: function readDs64Chunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('ds64');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this.ds64.chunkId = chunk.chunkId;\n        this.ds64.chunkSize = chunk.chunkSize;\n        this.ds64.riffSizeHigh = this.readUInt32(buffer);\n        this.ds64.riffSizeLow = this.readUInt32(buffer);\n        this.ds64.dataSizeHigh = this.readUInt32(buffer);\n        this.ds64.dataSizeLow = this.readUInt32(buffer);\n        this.ds64.originationTime = this.readUInt32(buffer);\n        this.ds64.sampleCountHigh = this.readUInt32(buffer);\n        this.ds64.sampleCountLow = this.readUInt32(buffer); //if (wav.ds64.chunkSize > 28) {\n        //  wav.ds64.tableLength = unpack(\n        //    chunkData.slice(28, 32), uInt32_);\n        //  wav.ds64.table = chunkData.slice(\n        //     32, 32 + wav.ds64.tableLength);\n        //}\n      } else {\n        if (this.container == 'RF64') {\n          throw Error('Could not find the \"ds64\" chunk');\n        }\n      }\n    }\n    /**\r\n     * Read the 'LIST' chunks of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readLISTChunk_\",\n    value: function readLISTChunk_(buffer) {\n      /** @type {?Object} */\n      var listChunks = this.findChunk('LIST', true);\n\n      if (listChunks !== null) {\n        for (var j = 0; j < listChunks.length; j++) {\n          /** @type {!Object} */\n          var subChunk = listChunks[j];\n          this.LIST.push({\n            chunkId: subChunk.chunkId,\n            chunkSize: subChunk.chunkSize,\n            format: subChunk.format,\n            subChunks: []\n          });\n\n          for (var x = 0; x < subChunk.subChunks.length; x++) {\n            this.readLISTSubChunks_(subChunk.subChunks[x], subChunk.format, buffer);\n          }\n        }\n      }\n    }\n    /**\r\n     * Read the sub chunks of a 'LIST' chunk.\r\n     * @param {!Object} subChunk The 'LIST' subchunks.\r\n     * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readLISTSubChunks_\",\n    value: function readLISTSubChunks_(subChunk, format, buffer) {\n      if (format == 'adtl') {\n        if (['labl', 'note', 'ltxt'].indexOf(subChunk.chunkId) > -1) {\n          this.readLISTadtlSubChunks_(buffer, subChunk);\n        } // RIFF INFO tags like ICRD, ISFT, ICMT\n\n      } else if (format == 'INFO') {\n        this.readLISTINFOSubChunks_(buffer, subChunk);\n      }\n    }\n    /**\r\n     * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @param {!Object} subChunk The 'LIST' subchunks.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readLISTadtlSubChunks_\",\n    value: function readLISTadtlSubChunks_(buffer, subChunk) {\n      this.head = subChunk.chunkData.start;\n      /** @type {!Object<string, string|number>} */\n\n      var item = {\n        chunkId: subChunk.chunkId,\n        chunkSize: subChunk.chunkSize,\n        dwName: this.readUInt32(buffer)\n      };\n\n      if (subChunk.chunkId == 'ltxt') {\n        item.dwSampleLength = this.readUInt32(buffer);\n        item.dwPurposeID = this.readUInt32(buffer);\n        item.dwCountry = this.readUInt16_(buffer);\n        item.dwLanguage = this.readUInt16_(buffer);\n        item.dwDialect = this.readUInt16_(buffer);\n        item.dwCodePage = this.readUInt16_(buffer);\n        item.value = ''; // kept for compatibility\n      } else {\n        item.value = this.readZSTR_(buffer, this.head);\n      }\n\n      this.LIST[this.LIST.length - 1].subChunks.push(item);\n    }\n    /**\r\n     * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @param {!Object} subChunk The 'LIST' subchunks.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readLISTINFOSubChunks_\",\n    value: function readLISTINFOSubChunks_(buffer, subChunk) {\n      this.head = subChunk.chunkData.start;\n      this.LIST[this.LIST.length - 1].subChunks.push({\n        chunkId: subChunk.chunkId,\n        chunkSize: subChunk.chunkSize,\n        value: this.readZSTR_(buffer, this.head)\n      });\n    }\n    /**\r\n     * Read the 'junk' chunk of a wave file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readJunkChunk_\",\n    value: function readJunkChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('junk');\n\n      if (chunk) {\n        this.junk = {\n          chunkId: chunk.chunkId,\n          chunkSize: chunk.chunkSize,\n          chunkData: [].slice.call(buffer.slice(chunk.chunkData.start, chunk.chunkData.end))\n        };\n      }\n    }\n    /**\r\n     * Read the '_PMX' chunk of a wav file.\r\n     * @param {!Uint8Array} buffer The wav file buffer.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"read_PMXChunk_\",\n    value: function read_PMXChunk_(buffer) {\n      /** @type {?Object} */\n      var chunk = this.findChunk('_PMX');\n\n      if (chunk) {\n        this.head = chunk.chunkData.start;\n        this._PMX.chunkId = chunk.chunkId;\n        this._PMX.chunkSize = chunk.chunkSize;\n        this._PMX.value = unpackString(buffer, this.head, this.head + this._PMX.chunkSize);\n      }\n    }\n    /**\r\n     * Read bytes as a ZSTR string.\r\n     * @param {!Uint8Array} bytes The bytes.\r\n     * @param {number=} [index=0] the index to start reading.\r\n     * @return {string} The string.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readZSTR_\",\n    value: function readZSTR_(bytes) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      for (var i = index; i < bytes.length; i++) {\n        this.head++;\n\n        if (bytes[i] === 0) {\n          break;\n        }\n      }\n\n      return unpackString(bytes, index, this.head - 1);\n    }\n    /**\r\n     * Read a number from a chunk.\r\n     * @param {!Uint8Array} bytes The chunk bytes.\r\n     * @return {number} The number.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"readUInt16_\",\n    value: function readUInt16_(bytes) {\n      /** @type {number} */\n      var value = unpack(bytes, this.uInt16, this.head);\n      this.head += 2;\n      return value;\n    }\n  }]);\n\n  return WaveFileReader;\n}(RIFFFile);","map":{"version":3,"sources":["/Users/eric/test/herokutestcs/my-app/node_modules/wavefile/lib/wavefile-reader.js"],"names":["RIFFFile","unpackString","unpack","WaveFileReader","supported_containers","push","fmt","chunkId","chunkSize","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","cbSize","validBitsPerSample","dwChannelMask","subformat","fact","dwSampleLength","cue","dwCuePoints","points","smpl","dwManufacturer","dwProduct","dwSamplePeriod","dwMIDIUnityNote","dwMIDIPitchFraction","dwSMPTEFormat","dwSMPTEOffset","dwNumSampleLoops","dwSamplerData","loops","bext","description","originator","originatorReference","originationDate","originationTime","timeReference","version","UMID","loudnessValue","loudnessRange","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","reserved","codingHistory","iXML","value","ds64","riffSizeHigh","riffSizeLow","dataSizeHigh","dataSizeLow","sampleCountHigh","sampleCountLow","data","samples","Uint8Array","LIST","junk","chunkData","_PMX","uInt16","bits","be","signed","fp","wavBuffer","clearHeaders","setSignature","uInt32","format","Error","readDs64Chunk_","readFmtChunk_","readFactChunk_","readBextChunk_","readiXMLChunk_","readCueChunk_","readSmplChunk_","readDataChunk_","readJunkChunk_","readLISTChunk_","read_PMXChunk_","tmpWav","Object","assign","buffer","chunk","findChunk","head","start","readUInt16_","readUInt32","readFmtExtension_","i","dwName","dwPosition","fccChunk","readString","dwChunkStart","dwBlockStart","dwSampleOffset","dwType","dwStart","dwEnd","dwFraction","dwPlayCount","slice","end","container","listChunks","j","length","subChunk","subChunks","x","readLISTSubChunks_","indexOf","readLISTadtlSubChunks_","readLISTINFOSubChunks_","item","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","readZSTR_","call","bytes","index"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { RIFFFile } from './riff-file';\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\r\nexport class WaveFileReader extends RIFFFile {\r\n\r\n  constructor() {\r\n    super();\r\n    // Include 'RF64' as a supported container format\r\n    this.supported_containers.push('RF64');\r\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fmt = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      audioFormat: 0,\r\n      /** @type {number} */\r\n      numChannels: 0,\r\n      /** @type {number} */\r\n      sampleRate: 0,\r\n      /** @type {number} */\r\n      byteRate: 0,\r\n      /** @type {number} */\r\n      blockAlign: 0,\r\n      /** @type {number} */\r\n      bitsPerSample: 0,\r\n      /** @type {number} */\r\n      cbSize: 0,\r\n      /** @type {number} */\r\n      validBitsPerSample: 0,\r\n      /** @type {number} */\r\n      dwChannelMask: 0,\r\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\r\n      subformat: []\r\n    };\r\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fact = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwSampleLength: 0\r\n    };\r\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.cue = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwCuePoints: 0,\r\n      /** @type {!Array<!Object>} */\r\n      points: [],\r\n    };\r\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.smpl = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwManufacturer: 0,\r\n      /** @type {number} */\r\n      dwProduct: 0,\r\n      /** @type {number} */\r\n      dwSamplePeriod: 0,\r\n      /** @type {number} */\r\n      dwMIDIUnityNote: 0,\r\n      /** @type {number} */\r\n      dwMIDIPitchFraction: 0,\r\n      /** @type {number} */\r\n      dwSMPTEFormat: 0,\r\n      /** @type {number} */\r\n      dwSMPTEOffset: 0,\r\n      /** @type {number} */\r\n      dwNumSampleLoops: 0,\r\n      /** @type {number} */\r\n      dwSamplerData: 0,\r\n      /** @type {!Array<!Object>} */\r\n      loops: []\r\n    };\r\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.bext = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      description: '', //256\r\n      /** @type {string} */\r\n      originator: '', //32\r\n      /** @type {string} */\r\n      originatorReference: '', //32\r\n      /** @type {string} */\r\n      originationDate: '', //10\r\n      /** @type {string} */\r\n      originationTime: '', //8\r\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\r\n      timeReference: [0, 0],\r\n      /** @type {number} */\r\n      version: 0, //WORD\r\n      /** @type {string} */\r\n      UMID: '', // 64 chars\r\n      /** @type {number} */\r\n      loudnessValue: 0, //WORD\r\n      /** @type {number} */\r\n      loudnessRange: 0, //WORD\r\n      /** @type {number} */\r\n      maxTruePeakLevel: 0, //WORD\r\n      /** @type {number} */\r\n      maxMomentaryLoudness: 0, //WORD\r\n      /** @type {number} */\r\n      maxShortTermLoudness: 0, //WORD\r\n      /** @type {string} */\r\n      reserved: '', //180\r\n      /** @type {string} */\r\n      codingHistory: '' // string, unlimited\r\n    };\r\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.iXML = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.ds64 = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      riffSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      riffSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      originationTime: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountLow: 0 // DWORD\r\n      /** @type {number} */\r\n      //'tableLength': 0, // DWORD\r\n      /** @type {!Array<number>} */\r\n      //'table': []\r\n    };\r\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.data = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Uint8Array} */\r\n      samples: new Uint8Array(0)\r\n    };\r\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\r\n    this.LIST = [];\r\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.junk = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Array<number>} */\r\n      chunkData: []\r\n    };\r\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this._PMX = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt16 = {bits: 16, be: false, signed: false, fp: false};\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    // Always should reset the chunks when reading from a buffer\r\n    this.clearHeaders();\r\n    this.setSignature(wavBuffer);\r\n    this.uInt16.be = this.uInt32.be;\r\n    if (this.format != 'WAVE') {\r\n      throw Error('Could not find the \"WAVE\" format identifier');\r\n    }\r\n    this.readDs64Chunk_(wavBuffer);\r\n    this.readFmtChunk_(wavBuffer);\r\n    this.readFactChunk_(wavBuffer);\r\n    this.readBextChunk_(wavBuffer);\r\n    this.readiXMLChunk_(wavBuffer);\r\n    this.readCueChunk_(wavBuffer);\r\n    this.readSmplChunk_(wavBuffer);\r\n    this.readDataChunk_(wavBuffer, samples);\r\n    this.readJunkChunk_(wavBuffer);\r\n    this.readLISTChunk_(wavBuffer);\r\n    this.read_PMXChunk_(wavBuffer);\r\n  }\r\n\r\n  /**\r\n   * Reset the chunks of the WaveFileReader instance.\r\n   * @protected\r\n   * @ignore\r\n   */\r\n  clearHeaders() {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileReader();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.cue, tmpWav.cue);\r\n    Object.assign(this.smpl, tmpWav.smpl);\r\n    Object.assign(this.bext, tmpWav.bext);\r\n    Object.assign(this.iXML, tmpWav.iXML);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.LIST = [];\r\n    Object.assign(this.junk, tmpWav.junk);\r\n    Object.assign(this._PMX, tmpWav._PMX);\r\n  }\r\n  \r\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\r\n  readFmtChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fmt ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fmt.chunkId = chunk.chunkId;\r\n      this.fmt.chunkSize = chunk.chunkSize;\r\n      this.fmt.audioFormat = this.readUInt16_(buffer);\r\n      this.fmt.numChannels = this.readUInt16_(buffer);\r\n      this.fmt.sampleRate = this.readUInt32(buffer);\r\n      this.fmt.byteRate = this.readUInt32(buffer);\r\n      this.fmt.blockAlign = this.readUInt16_(buffer);\r\n      this.fmt.bitsPerSample = this.readUInt16_(buffer);\r\n      this.readFmtExtension_(buffer);\r\n    } else {\r\n      throw Error('Could not find the \"fmt \" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFmtExtension_(buffer) {\r\n    if (this.fmt.chunkSize > 16) {\r\n      this.fmt.cbSize = this.readUInt16_(buffer);\r\n      if (this.fmt.chunkSize > 18) {\r\n        this.fmt.validBitsPerSample = this.readUInt16_(buffer);\r\n        if (this.fmt.chunkSize > 20) {\r\n          this.fmt.dwChannelMask = this.readUInt32(buffer);\r\n          this.fmt.subformat = [\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer)];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFactChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fact');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fact.chunkId = chunk.chunkId;\r\n      this.fact.chunkSize = chunk.chunkSize;\r\n      this.fact.dwSampleLength = this.readUInt32(buffer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readCueChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('cue ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.cue.chunkId = chunk.chunkId;\r\n      this.cue.chunkSize = chunk.chunkSize;\r\n      this.cue.dwCuePoints = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.cue.dwCuePoints; i++) {\r\n        this.cue.points.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwPosition: this.readUInt32(buffer),\r\n          fccChunk: this.readString(buffer, 4),\r\n          dwChunkStart: this.readUInt32(buffer),\r\n          dwBlockStart: this.readUInt32(buffer),\r\n          dwSampleOffset: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readSmplChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('smpl');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.smpl.chunkId = chunk.chunkId;\r\n      this.smpl.chunkSize = chunk.chunkSize;\r\n      this.smpl.dwManufacturer = this.readUInt32(buffer);\r\n      this.smpl.dwProduct = this.readUInt32(buffer);\r\n      this.smpl.dwSamplePeriod = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\r\n      this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\r\n      this.smpl.dwSamplerData = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\r\n        this.smpl.loops.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwType: this.readUInt32(buffer),\r\n          dwStart: this.readUInt32(buffer),\r\n          dwEnd: this.readUInt32(buffer),\r\n          dwFraction: this.readUInt32(buffer),\r\n          dwPlayCount: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {boolean} samples True if the samples should be loaded.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\r\n  readDataChunk_(buffer, samples) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('data');\r\n    if (chunk) {\r\n      this.data.chunkId = 'data';\r\n      this.data.chunkSize = chunk.chunkSize;\r\n      if (samples) {\r\n        this.data.samples = buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end);\r\n      }\r\n    } else {\r\n      throw Error('Could not find the \"data\" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readBextChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('bext');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.bext.chunkId = chunk.chunkId;\r\n      this.bext.chunkSize = chunk.chunkSize;\r\n      this.bext.description = this.readString(buffer, 256);\r\n      this.bext.originator = this.readString(buffer, 32);\r\n      this.bext.originatorReference = this.readString(buffer, 32);\r\n      this.bext.originationDate = this.readString(buffer, 10);\r\n      this.bext.originationTime = this.readString(buffer, 8);\r\n      this.bext.timeReference = [\r\n        this.readUInt32(buffer),\r\n        this.readUInt32(buffer)];\r\n      this.bext.version = this.readUInt16_(buffer);\r\n      this.bext.UMID = this.readString(buffer, 64);\r\n      this.bext.loudnessValue = this.readUInt16_(buffer);\r\n      this.bext.loudnessRange = this.readUInt16_(buffer);\r\n      this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\r\n      this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\r\n      this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\r\n      this.bext.reserved = this.readString(buffer, 180);\r\n      this.bext.codingHistory = this.readString(\r\n        buffer, this.bext.chunkSize - 602);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'iXML' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readiXMLChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('iXML');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.iXML.chunkId = chunk.chunkId;\r\n      this.iXML.chunkSize = chunk.chunkSize;\r\n      this.iXML.value = unpackString(\r\n        buffer, this.head, this.head + this.iXML.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\r\n  readDs64Chunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('ds64');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.ds64.chunkId = chunk.chunkId;\r\n      this.ds64.chunkSize = chunk.chunkSize;\r\n      this.ds64.riffSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.riffSizeLow = this.readUInt32(buffer);\r\n      this.ds64.dataSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.dataSizeLow = this.readUInt32(buffer);\r\n      this.ds64.originationTime = this.readUInt32(buffer);\r\n      this.ds64.sampleCountHigh = this.readUInt32(buffer);\r\n      this.ds64.sampleCountLow = this.readUInt32(buffer);\r\n      //if (wav.ds64.chunkSize > 28) {\r\n      //  wav.ds64.tableLength = unpack(\r\n      //    chunkData.slice(28, 32), uInt32_);\r\n      //  wav.ds64.table = chunkData.slice(\r\n      //     32, 32 + wav.ds64.tableLength);\r\n      //}\r\n    } else {\r\n      if (this.container == 'RF64') {\r\n        throw Error('Could not find the \"ds64\" chunk');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let listChunks = this.findChunk('LIST', true);\r\n    if (listChunks !== null) {\r\n      for (let j=0; j < listChunks.length; j++) {\r\n        /** @type {!Object} */\r\n        let subChunk = listChunks[j];\r\n        this.LIST.push({\r\n          chunkId: subChunk.chunkId,\r\n          chunkSize: subChunk.chunkSize,\r\n          format: subChunk.format,\r\n          subChunks: []});\r\n        for (let x=0; x<subChunk.subChunks.length; x++) {\r\n          this.readLISTSubChunks_(subChunk.subChunks[x],\r\n            subChunk.format, buffer);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTSubChunks_(subChunk, format, buffer) {\r\n    if (format == 'adtl') {\r\n      if (['labl', 'note','ltxt'].indexOf(subChunk.chunkId) > -1) {\r\n        this.readLISTadtlSubChunks_(buffer, subChunk);\r\n      }\r\n    // RIFF INFO tags like ICRD, ISFT, ICMT\r\n    } else if(format == 'INFO') {\r\n      this.readLISTINFOSubChunks_(buffer, subChunk);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTadtlSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    /** @type {!Object<string, string|number>} */\r\n    let item = {\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      dwName: this.readUInt32(buffer)\r\n    };\r\n    if (subChunk.chunkId == 'ltxt') {\r\n      item.dwSampleLength = this.readUInt32(buffer);\r\n      item.dwPurposeID = this.readUInt32(buffer);\r\n      item.dwCountry = this.readUInt16_(buffer);\r\n      item.dwLanguage = this.readUInt16_(buffer);\r\n      item.dwDialect = this.readUInt16_(buffer);\r\n      item.dwCodePage = this.readUInt16_(buffer);\r\n      item.value = ''; // kept for compatibility\r\n    } else {\r\n      item.value = this.readZSTR_(buffer, this.head);\r\n    }\r\n    this.LIST[this.LIST.length - 1].subChunks.push(item);\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTINFOSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    this.LIST[this.LIST.length - 1].subChunks.push({\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      value: this.readZSTR_(buffer, this.head)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readJunkChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('junk');\r\n    if (chunk) {\r\n      this.junk = {\r\n        chunkId: chunk.chunkId,\r\n        chunkSize: chunk.chunkSize,\r\n        chunkData: [].slice.call(buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end))\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the '_PMX' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  read_PMXChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('_PMX');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this._PMX.chunkId = chunk.chunkId;\r\n      this._PMX.chunkSize = chunk.chunkSize;\r\n      this._PMX.value = unpackString(\r\n        buffer, this.head, this.head + this._PMX.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number=} [index=0] the index to start reading.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readZSTR_(bytes, index=0) {\r\n    for (let i = index; i < bytes.length; i++) {\r\n      this.head++;\r\n      if (bytes[i] === 0) {\r\n        break;\r\n      }\r\n    }\r\n    return unpackString(bytes, index, this.head - 1);\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @private\r\n   */\r\n  readUInt16_(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt16, this.head);\r\n    this.head += 2;\r\n    return value;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}