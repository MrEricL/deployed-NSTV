{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileParser } from './wavefile-parser';\nimport { interleave, deInterleave } from './parsers/interleave';\nimport { validateNumChannels } from './validators/validate-num-channels';\nimport { validateSampleRate } from './validators/validate-sample-rate';\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\n\nexport var WaveFileCreator = /*#__PURE__*/function (_WaveFileParser) {\n  _inherits(WaveFileCreator, _WaveFileParser);\n\n  var _super = _createSuper(WaveFileCreator);\n\n  function WaveFileCreator() {\n    var _this;\n\n    _classCallCheck(this, WaveFileCreator);\n\n    _this = _super.call(this);\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\n\n    _this.bitDepth = '0';\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\n\n    _this.dataType = {\n      bits: 0,\n      be: false\n    };\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\n\n    _this.WAV_AUDIO_FORMATS = {\n      '4': 17,\n      '8': 1,\n      '8a': 6,\n      '8m': 7,\n      '16': 1,\n      '24': 1,\n      '32': 1,\n      '32f': 3,\n      '64': 3\n    };\n    return _this;\n  }\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\n\n\n  _createClass(WaveFileCreator, [{\n    key: \"fromScratch\",\n    value: function fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\n      options = options || {}; // reset all chunks\n\n      this.clearHeaders();\n      this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\n    }\n    /**\r\n     * Set up the WaveFileParser object from a byte buffer.\r\n     * @param {!Uint8Array} wavBuffer The buffer.\r\n     * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n     * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n     * @throws {Error} If format is not WAVE.\r\n     * @throws {Error} If no 'fmt ' chunk is found.\r\n     * @throws {Error} If no 'data' chunk is found.\r\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(wavBuffer) {\n      var samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      _get(_getPrototypeOf(WaveFileCreator.prototype), \"fromBuffer\", this).call(this, wavBuffer, samples);\n\n      this.bitDepthFromFmt_();\n      this.updateDataType_();\n    }\n    /**\r\n     * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n     * The return value of this method can be written straight to disk.\r\n     * @return {!Uint8Array} A wav file.\r\n     * @throws {Error} If bit depth is invalid.\r\n     * @throws {Error} If the number of channels is invalid.\r\n     * @throws {Error} If the sample rate is invalid.\r\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      this.validateWavHeader_();\n      return _get(_getPrototypeOf(WaveFileCreator.prototype), \"toBuffer\", this).call(this);\n    }\n    /**\r\n     * Return the samples packed in a Float64Array.\r\n     * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n     *   false to return the samples de-interleaved.\r\n     * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n     * @return {!(Array|TypedArray)} the samples.\r\n     */\n\n  }, {\n    key: \"getSamples\",\n    value: function getSamples() {\n      var interleaved = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var OutputObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float64Array;\n\n      /**\r\n       * A Float64Array created with a size to match the\r\n       * the length of the samples.\r\n       * @type {!(Array|TypedArray)}\r\n       */\n      var samples = new OutputObject(this.data.samples.length / (this.dataType.bits / 8)); // Unpack all the samples\n\n      unpackArrayTo(this.data.samples, this.dataType, samples, 0, this.data.samples.length);\n\n      if (!interleaved && this.fmt.numChannels > 1) {\n        return deInterleave(samples, this.fmt.numChannels, OutputObject);\n      }\n\n      return samples;\n    }\n    /**\r\n     * Return the sample at a given index.\r\n     * @param {number} index The sample index.\r\n     * @return {number} The sample.\r\n     * @throws {Error} If the sample index is off range.\r\n     */\n\n  }, {\n    key: \"getSample\",\n    value: function getSample(index) {\n      index = index * (this.dataType.bits / 8);\n\n      if (index + this.dataType.bits / 8 > this.data.samples.length) {\n        throw new Error('Range error');\n      }\n\n      return unpack(this.data.samples.slice(index, index + this.dataType.bits / 8), this.dataType);\n    }\n    /**\r\n     * Set the sample at a given index.\r\n     * @param {number} index The sample index.\r\n     * @param {number} sample The sample.\r\n     * @throws {Error} If the sample index is off range.\r\n     */\n\n  }, {\n    key: \"setSample\",\n    value: function setSample(index, sample) {\n      index = index * (this.dataType.bits / 8);\n\n      if (index + this.dataType.bits / 8 > this.data.samples.length) {\n        throw new Error('Range error');\n      }\n\n      packTo(sample, this.dataType, this.data.samples, index, true);\n    }\n    /**\r\n     * Return the value of the iXML chunk.\r\n     * @return {string} The contents of the iXML chunk.\r\n     */\n\n  }, {\n    key: \"getiXML\",\n    value: function getiXML() {\n      return this.iXML.value;\n    }\n    /**\r\n     * Set the value of the iXML chunk.\r\n     * @param {string} iXMLValue The value for the iXML chunk.\r\n     * @throws {TypeError} If the value is not a string.\r\n     */\n\n  }, {\n    key: \"setiXML\",\n    value: function setiXML(iXMLValue) {\n      if (typeof iXMLValue !== 'string') {\n        throw new TypeError('iXML value must be a string.');\n      }\n\n      this.iXML.value = iXMLValue;\n      this.iXML.chunkId = 'iXML';\n    }\n    /**\r\n     * Get the value of the _PMX chunk.\r\n     * @return {string} The contents of the _PMX chunk.\r\n     */\n\n  }, {\n    key: \"get_PMX\",\n    value: function get_PMX() {\n      return this._PMX.value;\n    }\n    /**\r\n     * Set the value of the _PMX chunk.\r\n     * @param {string} _PMXValue The value for the _PMX chunk.\r\n     * @throws {TypeError} If the value is not a string.\r\n     */\n\n  }, {\n    key: \"set_PMX\",\n    value: function set_PMX(_PMXValue) {\n      if (typeof _PMXValue !== 'string') {\n        throw new TypeError('_PMX value must be a string.');\n      }\n\n      this._PMX.value = _PMXValue;\n      this._PMX.chunkId = '_PMX';\n    }\n    /**\r\n     * Set up the WaveFileCreator object based on the arguments passed.\r\n     * @param {number} numChannels The number of channels.\r\n     * @param {number} sampleRate The sample rate.\r\n     *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n     * @param {string} bitDepthCode The audio bit depth code.\r\n     *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n     *   or any value between '8' and '32' (like '12').\r\n     * @param {!(Array|TypedArray)} samples The samples.\r\n     * @param {Object} options Used to define the container.\r\n     * @throws {Error} If any argument does not meet the criteria.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"newWavFile_\",\n    value: function newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\n      if (!options.container) {\n        options.container = 'RIFF';\n      }\n\n      this.container = options.container;\n      this.bitDepth = bitDepthCode;\n      samples = interleave(samples);\n      this.updateDataType_();\n      /** @type {number} */\n\n      var numBytes = this.dataType.bits / 8;\n      this.data.samples = new Uint8Array(samples.length * numBytes);\n      packArrayTo(samples, this.dataType, this.data.samples, 0, true);\n      this.makeWavHeader_(bitDepthCode, numChannels, sampleRate, numBytes, this.data.samples.length, options);\n      this.data.chunkId = 'data';\n      this.data.chunkSize = this.data.samples.length;\n      this.validateWavHeader_();\n    }\n    /**\r\n     * Define the header of a wav file.\r\n     * @param {string} bitDepthCode The audio bit depth\r\n     * @param {number} numChannels The number of channels\r\n     * @param {number} sampleRate The sample rate.\r\n     * @param {number} numBytes The number of bytes each sample use.\r\n     * @param {number} samplesLength The length of the samples in bytes.\r\n     * @param {!Object} options The extra options, like container defintion.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"makeWavHeader_\",\n    value: function makeWavHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n      if (bitDepthCode == '4') {\n        this.createADPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\n        this.createALawMulawHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      } else if (Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 || numChannels > 2) {\n        this.createExtensibleHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      } else {\n        this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      }\n    }\n    /**\r\n     * Create the header of a linear PCM wave file.\r\n     * @param {string} bitDepthCode The audio bit depth\r\n     * @param {number} numChannels The number of channels\r\n     * @param {number} sampleRate The sample rate.\r\n     * @param {number} numBytes The number of bytes each sample use.\r\n     * @param {number} samplesLength The length of the samples in bytes.\r\n     * @param {!Object} options The extra options, like container defintion.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"createPCMHeader_\",\n    value: function createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n      this.container = options.container;\n      this.chunkSize = 36 + samplesLength;\n      this.format = 'WAVE';\n      this.bitDepth = bitDepthCode;\n      this.fmt = {\n        chunkId: 'fmt ',\n        chunkSize: 16,\n        audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\n        numChannels: numChannels,\n        sampleRate: sampleRate,\n        byteRate: numChannels * numBytes * sampleRate,\n        blockAlign: numChannels * numBytes,\n        bitsPerSample: parseInt(bitDepthCode, 10),\n        cbSize: 0,\n        validBitsPerSample: 0,\n        dwChannelMask: 0,\n        subformat: []\n      };\n    }\n    /**\r\n     * Create the header of a ADPCM wave file.\r\n     * @param {string} bitDepthCode The audio bit depth\r\n     * @param {number} numChannels The number of channels\r\n     * @param {number} sampleRate The sample rate.\r\n     * @param {number} numBytes The number of bytes each sample use.\r\n     * @param {number} samplesLength The length of the samples in bytes.\r\n     * @param {!Object} options The extra options, like container defintion.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"createADPCMHeader_\",\n    value: function createADPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n      this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      this.chunkSize = 40 + samplesLength;\n      this.fmt.chunkSize = 20;\n      this.fmt.byteRate = 4055;\n      this.fmt.blockAlign = 256;\n      this.fmt.bitsPerSample = 4;\n      this.fmt.cbSize = 2;\n      this.fmt.validBitsPerSample = 505;\n      this.fact = {\n        chunkId: 'fact',\n        chunkSize: 4,\n        dwSampleLength: samplesLength * 2\n      };\n    }\n    /**\r\n     * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n     * @param {string} bitDepthCode The audio bit depth\r\n     * @param {number} numChannels The number of channels\r\n     * @param {number} sampleRate The sample rate.\r\n     * @param {number} numBytes The number of bytes each sample use.\r\n     * @param {number} samplesLength The length of the samples in bytes.\r\n     * @param {!Object} options The extra options, like container defintion.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"createExtensibleHeader_\",\n    value: function createExtensibleHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n      this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      this.chunkSize = 36 + 24 + samplesLength;\n      this.fmt.chunkSize = 40;\n      this.fmt.bitsPerSample = (parseInt(bitDepthCode, 10) - 1 | 7) + 1;\n      this.fmt.cbSize = 22;\n      this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\n      this.fmt.dwChannelMask = dwChannelMask_(numChannels); // subformat 128-bit GUID as 4 32-bit values\n      // only supports uncompressed integer PCM samples\n\n      this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\n    }\n    /**\r\n     * Create the header of mu-Law and A-Law wave files.\r\n     * @param {string} bitDepthCode The audio bit depth\r\n     * @param {number} numChannels The number of channels\r\n     * @param {number} sampleRate The sample rate.\r\n     * @param {number} numBytes The number of bytes each sample use.\r\n     * @param {number} samplesLength The length of the samples in bytes.\r\n     * @param {!Object} options The extra options, like container defintion.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"createALawMulawHeader_\",\n    value: function createALawMulawHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n      this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n      this.chunkSize = 40 + samplesLength;\n      this.fmt.chunkSize = 20;\n      this.fmt.cbSize = 2;\n      this.fmt.validBitsPerSample = 8;\n      this.fact = {\n        chunkId: 'fact',\n        chunkSize: 4,\n        dwSampleLength: samplesLength\n      };\n    }\n    /**\r\n     * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"bitDepthFromFmt_\",\n    value: function bitDepthFromFmt_() {\n      if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\n        this.bitDepth = '32f';\n      } else if (this.fmt.audioFormat === 6) {\n        this.bitDepth = '8a';\n      } else if (this.fmt.audioFormat === 7) {\n        this.bitDepth = '8m';\n      } else {\n        this.bitDepth = this.fmt.bitsPerSample.toString();\n      }\n    }\n    /**\r\n     * Validate the bit depth.\r\n     * @return {boolean} True is the bit depth is valid.\r\n     * @throws {Error} If bit depth is invalid.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"validateBitDepth_\",\n    value: function validateBitDepth_() {\n      if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\n        if (parseInt(this.bitDepth, 10) > 8 && parseInt(this.bitDepth, 10) < 54) {\n          return true;\n        }\n\n        throw new Error('Invalid bit depth.');\n      }\n\n      return true;\n    }\n    /**\r\n     * Update the type definition used to read and write the samples.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"updateDataType_\",\n    value: function updateDataType_() {\n      this.dataType = {\n        bits: (parseInt(this.bitDepth, 10) - 1 | 7) + 1,\n        fp: this.bitDepth == '32f' || this.bitDepth == '64',\n        signed: this.bitDepth != '8',\n        be: this.container == 'RIFX'\n      };\n\n      if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1) {\n        this.dataType.bits = 8;\n        this.dataType.signed = false;\n      }\n    }\n    /**\r\n     * Validate the header of the file.\r\n     * @throws {Error} If bit depth is invalid.\r\n     * @throws {Error} If the number of channels is invalid.\r\n     * @throws {Error} If the sample rate is invalid.\r\n     * @ignore\r\n     * @private\r\n     */\n\n  }, {\n    key: \"validateWavHeader_\",\n    value: function validateWavHeader_() {\n      this.validateBitDepth_();\n\n      if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\n        throw new Error('Invalid number of channels.');\n      }\n\n      if (!validateSampleRate(this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\n        throw new Error('Invalid sample rate.');\n      }\n    }\n  }]);\n\n  return WaveFileCreator;\n}(WaveFileParser);\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\n\nfunction dwChannelMask_(numChannels) {\n  /** @type {number} */\n  var mask = 0; // mono = FC\n\n  if (numChannels === 1) {\n    mask = 0x4; // stereo = FL, FR\n  } else if (numChannels === 2) {\n    mask = 0x3; // quad = FL, FR, BL, BR\n  } else if (numChannels === 4) {\n    mask = 0x33; // 5.1 = FL, FR, FC, LF, BL, BR\n  } else if (numChannels === 6) {\n    mask = 0x3F; // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\n  } else if (numChannels === 8) {\n    mask = 0x63F;\n  }\n\n  return mask;\n}","map":{"version":3,"sources":["/Users/eric/test/NSVT-FINAL/my-app/node_modules/wavefile/lib/wavefile-creator.js"],"names":["WaveFileParser","interleave","deInterleave","validateNumChannels","validateSampleRate","packArrayTo","unpackArrayTo","packTo","unpack","WaveFileCreator","bitDepth","dataType","bits","be","WAV_AUDIO_FORMATS","numChannels","sampleRate","bitDepthCode","samples","options","clearHeaders","newWavFile_","wavBuffer","bitDepthFromFmt_","updateDataType_","validateWavHeader_","interleaved","OutputObject","Float64Array","data","length","fmt","index","Error","slice","sample","iXML","value","iXMLValue","TypeError","chunkId","_PMX","_PMXValue","container","numBytes","Uint8Array","makeWavHeader_","chunkSize","samplesLength","createADPCMHeader_","createALawMulawHeader_","Object","keys","indexOf","createExtensibleHeader_","createPCMHeader_","format","audioFormat","byteRate","blockAlign","bitsPerSample","parseInt","cbSize","validBitsPerSample","dwChannelMask","subformat","fact","dwSampleLength","dwChannelMask_","toString","fp","signed","validateBitDepth_","mask"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA,SAASA,cAAT,QAA+B,mBAA/B;AACA,SAASC,UAAT,EAAqBC,YAArB,QAAyC,sBAAzC;AACA,SAASC,mBAAT,QAAoC,oCAApC;AACA,SAASC,kBAAT,QAAmC,mCAAnC;AACA,SAASC,WAAT,EAAsBC,aAAtB,EAAqCC,MAArC,EAA6CC,MAA7C,QAA2D,kBAA3D;AAEA;AACA;AACA;AACA;AACA;;AACA,WAAaC,eAAb;AAAA;;AAAA;;AAEE,6BAAc;AAAA;;AAAA;;AACZ;AACA;AACJ;AACA;AACA;;AACI,UAAKC,QAAL,GAAgB,GAAhB;AACA;AACJ;AACA;AACA;;AACI,UAAKC,QAAL,GAAgB;AAACC,MAAAA,IAAI,EAAE,CAAP;AAAUC,MAAAA,EAAE,EAAE;AAAd,KAAhB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,UAAKC,iBAAL,GAAyB;AACvB,WAAK,EADkB;AAEvB,WAAK,CAFkB;AAGvB,YAAM,CAHiB;AAIvB,YAAM,CAJiB;AAKvB,YAAM,CALiB;AAMvB,YAAM,CANiB;AAOvB,YAAM,CAPiB;AAQvB,aAAO,CARgB;AASvB,YAAM;AATiB,KAAzB;AAnBY;AA8Bb;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA/CA;AAAA;AAAA,WAgDE,qBAAYC,WAAZ,EAAyBC,UAAzB,EAAqCC,YAArC,EAAmDC,OAAnD,EAA4DC,OAA5D,EAAqE;AACnEA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CADmE,CAEnE;;AACA,WAAKC,YAAL;AACA,WAAKC,WAAL,CAAiBN,WAAjB,EAA8BC,UAA9B,EAA0CC,YAA1C,EAAwDC,OAAxD,EAAiEC,OAAjE;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/DA;AAAA;AAAA,WAgEE,oBAAWG,SAAX,EAAoC;AAAA,UAAdJ,OAAc,uEAAN,IAAM;;AAClC,sFAAiBI,SAAjB,EAA4BJ,OAA5B;;AACA,WAAKK,gBAAL;AACA,WAAKC,eAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AA7EA;AAAA;AAAA,WA8EE,oBAAW;AACT,WAAKC,kBAAL;AACA;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;AAzFA;AAAA;AAAA,WA0FE,sBAAyD;AAAA,UAA9CC,WAA8C,uEAAlC,KAAkC;AAAA,UAA3BC,YAA2B,uEAAdC,YAAc;;AACvD;AACJ;AACA;AACA;AACA;AACI,UAAIV,OAAO,GAAG,IAAIS,YAAJ,CACZ,KAAKE,IAAL,CAAUX,OAAV,CAAkBY,MAAlB,IAA4B,KAAKnB,QAAL,CAAcC,IAAd,GAAqB,CAAjD,CADY,CAAd,CANuD,CAQvD;;AACAN,MAAAA,aAAa,CAAC,KAAKuB,IAAL,CAAUX,OAAX,EAAoB,KAAKP,QAAzB,EAAmCO,OAAnC,EACX,CADW,EACR,KAAKW,IAAL,CAAUX,OAAV,CAAkBY,MADV,CAAb;;AAEA,UAAI,CAACJ,WAAD,IAAgB,KAAKK,GAAL,CAAShB,WAAT,GAAuB,CAA3C,EAA8C;AAC5C,eAAOb,YAAY,CAACgB,OAAD,EAAU,KAAKa,GAAL,CAAShB,WAAnB,EAAgCY,YAAhC,CAAnB;AACD;;AACD,aAAOT,OAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;AAhHA;AAAA;AAAA,WAiHE,mBAAUc,KAAV,EAAiB;AACfA,MAAAA,KAAK,GAAGA,KAAK,IAAI,KAAKrB,QAAL,CAAcC,IAAd,GAAqB,CAAzB,CAAb;;AACA,UAAIoB,KAAK,GAAG,KAAKrB,QAAL,CAAcC,IAAd,GAAqB,CAA7B,GAAiC,KAAKiB,IAAL,CAAUX,OAAV,CAAkBY,MAAvD,EAA+D;AAC7D,cAAM,IAAIG,KAAJ,CAAU,aAAV,CAAN;AACD;;AACD,aAAOzB,MAAM,CACX,KAAKqB,IAAL,CAAUX,OAAV,CAAkBgB,KAAlB,CAAwBF,KAAxB,EAA+BA,KAAK,GAAG,KAAKrB,QAAL,CAAcC,IAAd,GAAqB,CAA5D,CADW,EAEX,KAAKD,QAFM,CAAb;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;;AAhIA;AAAA;AAAA,WAiIE,mBAAUqB,KAAV,EAAiBG,MAAjB,EAAyB;AACvBH,MAAAA,KAAK,GAAGA,KAAK,IAAI,KAAKrB,QAAL,CAAcC,IAAd,GAAqB,CAAzB,CAAb;;AACA,UAAIoB,KAAK,GAAG,KAAKrB,QAAL,CAAcC,IAAd,GAAqB,CAA7B,GAAiC,KAAKiB,IAAL,CAAUX,OAAV,CAAkBY,MAAvD,EAA+D;AAC7D,cAAM,IAAIG,KAAJ,CAAU,aAAV,CAAN;AACD;;AACD1B,MAAAA,MAAM,CAAC4B,MAAD,EAAS,KAAKxB,QAAd,EAAwB,KAAKkB,IAAL,CAAUX,OAAlC,EAA2Cc,KAA3C,EAAkD,IAAlD,CAAN;AACD;AAED;AACF;AACA;AACA;;AA5IA;AAAA;AAAA,WA6IE,mBAAU;AACR,aAAO,KAAKI,IAAL,CAAUC,KAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;AArJA;AAAA;AAAA,WAsJE,iBAAQC,SAAR,EAAmB;AACjB,UAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,cAAM,IAAIC,SAAJ,CAAc,8BAAd,CAAN;AACD;;AACD,WAAKH,IAAL,CAAUC,KAAV,GAAkBC,SAAlB;AACA,WAAKF,IAAL,CAAUI,OAAV,GAAoB,MAApB;AACD;AAED;AACF;AACA;AACA;;AAjKA;AAAA;AAAA,WAkKE,mBAAU;AACR,aAAO,KAAKC,IAAL,CAAUJ,KAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;AA1KA;AAAA;AAAA,WA2KE,iBAAQK,SAAR,EAAmB;AACjB,UAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,cAAM,IAAIH,SAAJ,CAAc,8BAAd,CAAN;AACD;;AACD,WAAKE,IAAL,CAAUJ,KAAV,GAAkBK,SAAlB;AACA,WAAKD,IAAL,CAAUD,OAAV,GAAoB,MAApB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/LA;AAAA;AAAA,WAgME,qBAAYzB,WAAZ,EAAyBC,UAAzB,EAAqCC,YAArC,EAAmDC,OAAnD,EAA4DC,OAA5D,EAAqE;AACnE,UAAI,CAACA,OAAO,CAACwB,SAAb,EAAwB;AACtBxB,QAAAA,OAAO,CAACwB,SAAR,GAAoB,MAApB;AACD;;AACD,WAAKA,SAAL,GAAiBxB,OAAO,CAACwB,SAAzB;AACA,WAAKjC,QAAL,GAAgBO,YAAhB;AACAC,MAAAA,OAAO,GAAGjB,UAAU,CAACiB,OAAD,CAApB;AACA,WAAKM,eAAL;AACA;;AACA,UAAIoB,QAAQ,GAAG,KAAKjC,QAAL,CAAcC,IAAd,GAAqB,CAApC;AACA,WAAKiB,IAAL,CAAUX,OAAV,GAAoB,IAAI2B,UAAJ,CAAe3B,OAAO,CAACY,MAAR,GAAiBc,QAAhC,CAApB;AACAvC,MAAAA,WAAW,CAACa,OAAD,EAAU,KAAKP,QAAf,EAAyB,KAAKkB,IAAL,CAAUX,OAAnC,EAA4C,CAA5C,EAA+C,IAA/C,CAAX;AACA,WAAK4B,cAAL,CACE7B,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EAEE4B,QAFF,EAEY,KAAKf,IAAL,CAAUX,OAAV,CAAkBY,MAF9B,EAEsCX,OAFtC;AAGA,WAAKU,IAAL,CAAUW,OAAV,GAAoB,MAApB;AACA,WAAKX,IAAL,CAAUkB,SAAV,GAAsB,KAAKlB,IAAL,CAAUX,OAAV,CAAkBY,MAAxC;AACA,WAAKL,kBAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7NA;AAAA;AAAA,WA8NE,wBACER,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE,EAC2E;AACzE,UAAIF,YAAY,IAAI,GAApB,EAAyB;AACvB,aAAKgC,kBAAL,CACEhC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAGD,OAJD,MAIO,IAAIF,YAAY,IAAI,IAAhB,IAAwBA,YAAY,IAAI,IAA5C,EAAkD;AACvD,aAAKiC,sBAAL,CACEjC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAGD,OAJM,MAIA,IAAGgC,MAAM,CAACC,IAAP,CAAY,KAAKtC,iBAAjB,EAAoCuC,OAApC,CAA4CpC,YAA5C,KAA6D,CAAC,CAA9D,IACNF,WAAW,GAAG,CADX,EACc;AACnB,aAAKuC,uBAAL,CACErC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAGD,OALM,MAKA;AACL,aAAKoC,gBAAL,CACEtC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAED;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5PA;AAAA;AAAA,WA6PE,0BACEF,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE,EAC2E;AACzE,WAAKwB,SAAL,GAAiBxB,OAAO,CAACwB,SAAzB;AACA,WAAKI,SAAL,GAAiB,KAAKC,aAAtB;AACA,WAAKQ,MAAL,GAAc,MAAd;AACA,WAAK9C,QAAL,GAAgBO,YAAhB;AACA,WAAKc,GAAL,GAAW;AACTS,QAAAA,OAAO,EAAE,MADA;AAETO,QAAAA,SAAS,EAAE,EAFF;AAGTU,QAAAA,WAAW,EAAE,KAAK3C,iBAAL,CAAuBG,YAAvB,KAAwC,KAH5C;AAITF,QAAAA,WAAW,EAAEA,WAJJ;AAKTC,QAAAA,UAAU,EAAEA,UALH;AAMT0C,QAAAA,QAAQ,EAAG3C,WAAW,GAAG6B,QAAf,GAA2B5B,UAN5B;AAOT2C,QAAAA,UAAU,EAAE5C,WAAW,GAAG6B,QAPjB;AAQTgB,QAAAA,aAAa,EAAEC,QAAQ,CAAC5C,YAAD,EAAe,EAAf,CARd;AAST6C,QAAAA,MAAM,EAAE,CATC;AAUTC,QAAAA,kBAAkB,EAAE,CAVX;AAWTC,QAAAA,aAAa,EAAE,CAXN;AAYTC,QAAAA,SAAS,EAAE;AAZF,OAAX;AAcD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5RA;AAAA;AAAA,WA6RE,4BACEhD,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE,EAC2E;AACzE,WAAKoC,gBAAL,CACEtC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAEA,WAAK4B,SAAL,GAAiB,KAAKC,aAAtB;AACA,WAAKjB,GAAL,CAASgB,SAAT,GAAqB,EAArB;AACA,WAAKhB,GAAL,CAAS2B,QAAT,GAAoB,IAApB;AACA,WAAK3B,GAAL,CAAS4B,UAAT,GAAsB,GAAtB;AACA,WAAK5B,GAAL,CAAS6B,aAAT,GAAyB,CAAzB;AACA,WAAK7B,GAAL,CAAS+B,MAAT,GAAkB,CAAlB;AACA,WAAK/B,GAAL,CAASgC,kBAAT,GAA8B,GAA9B;AACA,WAAKG,IAAL,GAAY;AACV1B,QAAAA,OAAO,EAAE,MADC;AAEVO,QAAAA,SAAS,EAAE,CAFD;AAGVoB,QAAAA,cAAc,EAAEnB,aAAa,GAAG;AAHtB,OAAZ;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxTA;AAAA;AAAA,WAyTE,iCACI/B,YADJ,EACkBF,WADlB,EAC+BC,UAD/B,EAC2C4B,QAD3C,EACqDI,aADrD,EACoE7B,OADpE,EAC6E;AAC3E,WAAKoC,gBAAL,CACEtC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAEA,WAAK4B,SAAL,GAAiB,KAAK,EAAL,GAAUC,aAA3B;AACA,WAAKjB,GAAL,CAASgB,SAAT,GAAqB,EAArB;AACA,WAAKhB,GAAL,CAAS6B,aAAT,GAAyB,CAAEC,QAAQ,CAAC5C,YAAD,EAAe,EAAf,CAAR,GAA6B,CAA9B,GAAmC,CAApC,IAAyC,CAAlE;AACA,WAAKc,GAAL,CAAS+B,MAAT,GAAkB,EAAlB;AACA,WAAK/B,GAAL,CAASgC,kBAAT,GAA8BF,QAAQ,CAAC5C,YAAD,EAAe,EAAf,CAAtC;AACA,WAAKc,GAAL,CAASiC,aAAT,GAAyBI,cAAc,CAACrD,WAAD,CAAvC,CAR2E,CAS3E;AACA;;AACA,WAAKgB,GAAL,CAASkC,SAAT,GAAqB,CAAC,CAAD,EAAI,OAAJ,EAAa,UAAb,EAAyB,UAAzB,CAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjVA;AAAA;AAAA,WAkVE,gCACIhD,YADJ,EACkBF,WADlB,EAC+BC,UAD/B,EAC2C4B,QAD3C,EACqDI,aADrD,EACoE7B,OADpE,EAC6E;AAC3E,WAAKoC,gBAAL,CACEtC,YADF,EACgBF,WADhB,EAC6BC,UAD7B,EACyC4B,QADzC,EACmDI,aADnD,EACkE7B,OADlE;AAEA,WAAK4B,SAAL,GAAiB,KAAKC,aAAtB;AACA,WAAKjB,GAAL,CAASgB,SAAT,GAAqB,EAArB;AACA,WAAKhB,GAAL,CAAS+B,MAAT,GAAkB,CAAlB;AACA,WAAK/B,GAAL,CAASgC,kBAAT,GAA8B,CAA9B;AACA,WAAKG,IAAL,GAAY;AACV1B,QAAAA,OAAO,EAAE,MADC;AAEVO,QAAAA,SAAS,EAAE,CAFD;AAGVoB,QAAAA,cAAc,EAAEnB;AAHN,OAAZ;AAKD;AAED;AACF;AACA;AACA;;AApWA;AAAA;AAAA,WAqWE,4BAAmB;AACjB,UAAI,KAAKjB,GAAL,CAAS0B,WAAT,KAAyB,CAAzB,IAA8B,KAAK1B,GAAL,CAAS6B,aAAT,KAA2B,EAA7D,EAAiE;AAC/D,aAAKlD,QAAL,GAAgB,KAAhB;AACD,OAFD,MAEO,IAAI,KAAKqB,GAAL,CAAS0B,WAAT,KAAyB,CAA7B,EAAgC;AACrC,aAAK/C,QAAL,GAAgB,IAAhB;AACD,OAFM,MAEA,IAAI,KAAKqB,GAAL,CAAS0B,WAAT,KAAyB,CAA7B,EAAgC;AACrC,aAAK/C,QAAL,GAAgB,IAAhB;AACD,OAFM,MAEA;AACL,aAAKA,QAAL,GAAgB,KAAKqB,GAAL,CAAS6B,aAAT,CAAuBS,QAAvB,EAAhB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;AAtXA;AAAA;AAAA,WAuXE,6BAAoB;AAClB,UAAI,CAAC,KAAKvD,iBAAL,CAAuB,KAAKJ,QAA5B,CAAL,EAA4C;AAC1C,YAAImD,QAAQ,CAAC,KAAKnD,QAAN,EAAgB,EAAhB,CAAR,GAA8B,CAA9B,IACAmD,QAAQ,CAAC,KAAKnD,QAAN,EAAgB,EAAhB,CAAR,GAA8B,EADlC,EACsC;AACpC,iBAAO,IAAP;AACD;;AACD,cAAM,IAAIuB,KAAJ,CAAU,oBAAV,CAAN;AACD;;AACD,aAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;AArYA;AAAA;AAAA,WAsYE,2BAAkB;AAChB,WAAKtB,QAAL,GAAgB;AACdC,QAAAA,IAAI,EAAE,CAAEiD,QAAQ,CAAC,KAAKnD,QAAN,EAAgB,EAAhB,CAAR,GAA8B,CAA/B,GAAoC,CAArC,IAA0C,CADlC;AAEd4D,QAAAA,EAAE,EAAE,KAAK5D,QAAL,IAAiB,KAAjB,IAA0B,KAAKA,QAAL,IAAiB,IAFjC;AAGd6D,QAAAA,MAAM,EAAE,KAAK7D,QAAL,IAAiB,GAHX;AAIdG,QAAAA,EAAE,EAAE,KAAK8B,SAAL,IAAkB;AAJR,OAAhB;;AAMA,UAAI,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkBU,OAAlB,CAA0B,KAAK3C,QAA/B,IAA2C,CAAC,CAAhD,EAAoD;AAClD,aAAKC,QAAL,CAAcC,IAAd,GAAqB,CAArB;AACA,aAAKD,QAAL,CAAc4D,MAAd,GAAuB,KAAvB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AA1ZA;AAAA;AAAA,WA2ZE,8BAAqB;AACnB,WAAKC,iBAAL;;AACA,UAAI,CAACrE,mBAAmB,CAAC,KAAK4B,GAAL,CAAShB,WAAV,EAAuB,KAAKgB,GAAL,CAAS6B,aAAhC,CAAxB,EAAwE;AACtE,cAAM,IAAI3B,KAAJ,CAAU,6BAAV,CAAN;AACD;;AACD,UAAI,CAAC7B,kBAAkB,CACnB,KAAK2B,GAAL,CAAShB,WADU,EACG,KAAKgB,GAAL,CAAS6B,aADZ,EAC2B,KAAK7B,GAAL,CAASf,UADpC,CAAvB,EACwE;AACtE,cAAM,IAAIiB,KAAJ,CAAU,sBAAV,CAAN;AACD;AACF;AApaH;;AAAA;AAAA,EAAqCjC,cAArC;AAuaA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASoE,cAAT,CAAwBrD,WAAxB,EAAqC;AACnC;AACA,MAAI0D,IAAI,GAAG,CAAX,CAFmC,CAGnC;;AACA,MAAI1D,WAAW,KAAK,CAApB,EAAuB;AACrB0D,IAAAA,IAAI,GAAG,GAAP,CADqB,CAEvB;AACC,GAHD,MAGO,IAAI1D,WAAW,KAAK,CAApB,EAAuB;AAC5B0D,IAAAA,IAAI,GAAG,GAAP,CAD4B,CAE9B;AACC,GAHM,MAGA,IAAI1D,WAAW,KAAK,CAApB,EAAuB;AAC5B0D,IAAAA,IAAI,GAAG,IAAP,CAD4B,CAE9B;AACC,GAHM,MAGA,IAAI1D,WAAW,KAAK,CAApB,EAAuB;AAC5B0D,IAAAA,IAAI,GAAG,IAAP,CAD4B,CAE9B;AACC,GAHM,MAGA,IAAI1D,WAAW,KAAK,CAApB,EAAuB;AAC5B0D,IAAAA,IAAI,GAAG,KAAP;AACD;;AACD,SAAOA,IAAP;AACD","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileParser } from './wavefile-parser';\r\nimport { interleave, deInterleave } from './parsers/interleave';\r\nimport { validateNumChannels } from './validators/validate-num-channels'; \r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\r\nexport class WaveFileCreator extends WaveFileParser {\r\n\r\n  constructor() {\r\n    super();\r\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\r\n    this.bitDepth = '0';\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.dataType = {bits: 0, be: false};\r\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\r\n    this.WAV_AUDIO_FORMATS = {\r\n      '4': 17,\r\n      '8': 1,\r\n      '8a': 6,\r\n      '8m': 7,\r\n      '16': 1,\r\n      '24': 1,\r\n      '32': 1,\r\n      '32f': 3,\r\n      '64': 3\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\r\n  fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    options = options || {};\r\n    // reset all chunks\r\n    this.clearHeaders();\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileParser object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    super.fromBuffer(wavBuffer, samples);\r\n    this.bitDepthFromFmt_();\r\n    this.updateDataType_();\r\n  }\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   */\r\n  toBuffer() {\r\n    this.validateWavHeader_();\r\n    return super.toBuffer();\r\n  }\r\n\r\n  /**\r\n   * Return the samples packed in a Float64Array.\r\n   * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n   *   false to return the samples de-interleaved.\r\n   * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n   * @return {!(Array|TypedArray)} the samples.\r\n   */\r\n  getSamples(interleaved=false, OutputObject=Float64Array) {\r\n    /**\r\n     * A Float64Array created with a size to match the\r\n     * the length of the samples.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = new OutputObject(\r\n      this.data.samples.length / (this.dataType.bits / 8));\r\n    // Unpack all the samples\r\n    unpackArrayTo(this.data.samples, this.dataType, samples,\r\n      0, this.data.samples.length);\r\n    if (!interleaved && this.fmt.numChannels > 1) {\r\n      return deInterleave(samples, this.fmt.numChannels, OutputObject);\r\n    }\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * Return the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @return {number} The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  getSample(index) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    return unpack(\r\n      this.data.samples.slice(index, index + this.dataType.bits / 8),\r\n      this.dataType);\r\n  }\r\n\r\n  /**\r\n   * Set the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @param {number} sample The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  setSample(index, sample) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    packTo(sample, this.dataType, this.data.samples, index, true);\r\n  }\r\n\r\n  /**\r\n   * Return the value of the iXML chunk.\r\n   * @return {string} The contents of the iXML chunk.\r\n   */\r\n  getiXML() {\r\n    return this.iXML.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the iXML chunk.\r\n   * @param {string} iXMLValue The value for the iXML chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  setiXML(iXMLValue) {\r\n    if (typeof iXMLValue !== 'string') {\r\n      throw new TypeError('iXML value must be a string.');\r\n    }\r\n    this.iXML.value = iXMLValue;\r\n    this.iXML.chunkId = 'iXML';\r\n  }\r\n\r\n  /**\r\n   * Get the value of the _PMX chunk.\r\n   * @return {string} The contents of the _PMX chunk.\r\n   */\r\n  get_PMX() {\r\n    return this._PMX.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the _PMX chunk.\r\n   * @param {string} _PMXValue The value for the _PMX chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  set_PMX(_PMXValue) {\r\n    if (typeof _PMXValue !== 'string') {\r\n      throw new TypeError('_PMX value must be a string.');\r\n    }\r\n    this._PMX.value = _PMXValue;\r\n    this._PMX.chunkId = '_PMX';\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *   or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object} options Used to define the container.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    if (!options.container) {\r\n      options.container = 'RIFF';\r\n    }\r\n    this.container = options.container;\r\n    this.bitDepth = bitDepthCode;\r\n    samples = interleave(samples);\r\n    this.updateDataType_();\r\n    /** @type {number} */\r\n    let numBytes = this.dataType.bits / 8;\r\n    this.data.samples = new Uint8Array(samples.length * numBytes);\r\n    packArrayTo(samples, this.dataType, this.data.samples, 0, true);\r\n    this.makeWavHeader_(\r\n      bitDepthCode, numChannels, sampleRate,\r\n      numBytes, this.data.samples.length, options);\r\n    this.data.chunkId = 'data';\r\n    this.data.chunkSize = this.data.samples.length;\r\n    this.validateWavHeader_();\r\n  }\r\n\r\n  /**\r\n   * Define the header of a wav file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  makeWavHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    if (bitDepthCode == '4') {\r\n      this.createADPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\r\n      this.createALawMulawHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if(Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 ||\r\n        numChannels > 2) {\r\n      this.createExtensibleHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else {\r\n      this.createPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);      \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.container = options.container;\r\n    this.chunkSize = 36 + samplesLength;\r\n    this.format = 'WAVE';\r\n    this.bitDepth = bitDepthCode;\r\n    this.fmt = {\r\n      chunkId: 'fmt ',\r\n      chunkSize: 16,\r\n      audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\r\n      numChannels: numChannels,\r\n      sampleRate: sampleRate,\r\n      byteRate: (numChannels * numBytes) * sampleRate,\r\n      blockAlign: numChannels * numBytes,\r\n      bitsPerSample: parseInt(bitDepthCode, 10),\r\n      cbSize: 0,\r\n      validBitsPerSample: 0,\r\n      dwChannelMask: 0,\r\n      subformat: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createADPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.byteRate = 4055;\r\n    this.fmt.blockAlign = 256;\r\n    this.fmt.bitsPerSample = 4;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 505;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength * 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createExtensibleHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 36 + 24 + samplesLength;\r\n    this.fmt.chunkSize = 40;\r\n    this.fmt.bitsPerSample = ((parseInt(bitDepthCode, 10) - 1) | 7) + 1;\r\n    this.fmt.cbSize = 22;\r\n    this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\r\n    this.fmt.dwChannelMask = dwChannelMask_(numChannels);\r\n    // subformat 128-bit GUID as 4 32-bit values\r\n    // only supports uncompressed integer PCM samples\r\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\r\n  }\r\n\r\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createALawMulawHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 8;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\r\n  bitDepthFromFmt_() {\r\n    if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\r\n      this.bitDepth = '32f';\r\n    } else if (this.fmt.audioFormat === 6) {\r\n      this.bitDepth = '8a';\r\n    } else if (this.fmt.audioFormat === 7) {\r\n      this.bitDepth = '8m';\r\n    } else {\r\n      this.bitDepth = this.fmt.bitsPerSample.toString();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\r\n  validateBitDepth_() {\r\n    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\r\n      if (parseInt(this.bitDepth, 10) > 8 &&\r\n          parseInt(this.bitDepth, 10) < 54) {\r\n        return true;\r\n      }\r\n      throw new Error('Invalid bit depth.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Update the type definition used to read and write the samples.\r\n   * @private\r\n   */\r\n  updateDataType_() {\r\n    this.dataType = {\r\n      bits: ((parseInt(this.bitDepth, 10) - 1) | 7) + 1,\r\n      fp: this.bitDepth == '32f' || this.bitDepth == '64',\r\n      signed: this.bitDepth != '8',\r\n      be: this.container == 'RIFX'\r\n    };\r\n    if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1 ) {\r\n      this.dataType.bits = 8;\r\n      this.dataType.signed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @ignore\r\n   * @private\r\n   */\r\n  validateWavHeader_() {\r\n    this.validateBitDepth_();\r\n    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\r\n      throw new Error('Invalid number of channels.');\r\n    }\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\r\nfunction dwChannelMask_(numChannels) {\r\n  /** @type {number} */\r\n  let mask = 0;\r\n  // mono = FC\r\n  if (numChannels === 1) {\r\n    mask = 0x4;\r\n  // stereo = FL, FR\r\n  } else if (numChannels === 2) {\r\n    mask = 0x3;\r\n  // quad = FL, FR, BL, BR\r\n  } else if (numChannels === 4) {\r\n    mask = 0x33;\r\n  // 5.1 = FL, FR, FC, LF, BL, BR\r\n  } else if (numChannels === 6) {\r\n    mask = 0x3F;\r\n  // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\r\n  } else if (numChannels === 8) {\r\n    mask = 0x63F;\r\n  }\r\n  return mask;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}