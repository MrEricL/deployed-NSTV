{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\n\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\nexport var IntParser = /*#__PURE__*/function () {\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\n  function IntParser(bits) {\n    var signed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, IntParser);\n\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\n    this.bits = bits;\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\n\n    this.offset = Math.ceil(bits / 8);\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n\n    this.max = Math.pow(2, bits) - 1;\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n\n    this.min = 0;\n    /**\r\n     * @type {Function}\r\n     */\n\n    this.unpack = this.unpack_;\n\n    if (signed) {\n      this.max = Math.pow(2, bits) / 2 - 1;\n      this.min = -this.max - 1;\n      this.unpack = this.unpackSigned_;\n    }\n  }\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\n\n\n  _createClass(IntParser, [{\n    key: \"pack\",\n    value: function pack(buffer, num) {\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      num = this.clamp_(Math.round(num));\n\n      for (var i = 0, len = this.offset; i < len; i++) {\n        buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\n        index++;\n      }\n\n      return index;\n    }\n    /**\r\n     * Read one unsigned integer from a byte buffer.\r\n     * Does not check for overflows.\r\n     * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n     * @param {number} [index=0] The index to read.\r\n     * @return {number}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"unpack_\",\n    value: function unpack_(buffer) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      /** @type {number} */\n      var num = 0;\n\n      for (var x = 0; x < this.offset; x++) {\n        num += buffer[index + x] * Math.pow(256, x);\n      }\n\n      return num;\n    }\n    /**\r\n     * Read one two's complement signed integer from a byte buffer.\r\n     * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n     * @param {number} [index=0] The index to read.\r\n     * @return {number}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"unpackSigned_\",\n    value: function unpackSigned_(buffer) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.sign_(this.unpack_(buffer, index));\n    }\n    /**\r\n     * Clamp values on overflow.\r\n     * @param {number} num The number.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"clamp_\",\n    value: function clamp_(num) {\n      if (num > this.max) {\n        return this.max;\n      } else if (num < this.min) {\n        return this.min;\n      }\n\n      return num;\n    }\n    /**\r\n     * Sign a number.\r\n     * @param {number} num The number.\r\n     * @return {number}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"sign_\",\n    value: function sign_(num) {\n      if (num > this.max) {\n        num -= this.max * 2 + 2;\n      }\n\n      return num;\n    }\n  }]);\n\n  return IntParser;\n}();","map":{"version":3,"sources":["/Users/eric/test/herokutestcs/my-app/node_modules/wavefile/lib/parsers/binary/lib/int-parser.js"],"names":["IntParser","bits","signed","offset","Math","ceil","max","pow","min","unpack","unpack_","unpackSigned_","buffer","num","index","clamp_","round","i","len","floor","x","sign_"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\r\nexport class IntParser {\r\n  \r\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\r\n  constructor(bits, signed=false) {\r\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil(bits / 8);\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.max = Math.pow(2, bits) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.min = 0;\r\n    /**\r\n     * @type {Function}\r\n     */\r\n    this.unpack = this.unpack_;\r\n    if (signed) {\r\n      this.max = Math.pow(2, bits) / 2 - 1;\r\n      this.min = -this.max - 1;\r\n      this.unpack = this.unpackSigned_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  pack(buffer, num, index=0) {\r\n    num = this.clamp_(Math.round(num));\r\n    for (let i = 0, len = this.offset; i < len; i++) {\r\n      buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\r\n      index++;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpack_(buffer, index=0) {\r\n    /** @type {number} */\r\n    let num = 0;\r\n    for(let x = 0; x < this.offset; x++) {\r\n      num += buffer[index + x] * Math.pow(256, x);\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpackSigned_(buffer, index=0) {\r\n    return this.sign_(this.unpack_(buffer, index));\r\n  }\r\n\r\n  /**\r\n   * Clamp values on overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\r\n  clamp_(num) {\r\n    if (num > this.max) {\r\n      return this.max;\r\n    } else if (num < this.min) {\r\n      return this.min;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}