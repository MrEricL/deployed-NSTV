{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileTagEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileCreator } from './wavefile-creator';\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileCreator\r\n * @ignore\r\n */\n\nexport var WaveFileTagEditor = /*#__PURE__*/function (_WaveFileCreator) {\n  _inherits(WaveFileTagEditor, _WaveFileCreator);\n\n  var _super = _createSuper(WaveFileTagEditor);\n\n  function WaveFileTagEditor() {\n    _classCallCheck(this, WaveFileTagEditor);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(WaveFileTagEditor, [{\n    key: \"getTag\",\n    value:\n    /**\r\n     * Return the value of a RIFF tag in the INFO chunk.\r\n     * @param {string} tag The tag name.\r\n     * @return {?string} The value if the tag is found, null otherwise.\r\n     */\n    function getTag(tag) {\n      /** @type {!Object} */\n      var index = this.getTagIndex_(tag);\n\n      if (index.TAG !== null) {\n        return this.LIST[index.LIST].subChunks[index.TAG].value;\n      }\n\n      return null;\n    }\n    /**\r\n     * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n     * then it is created. It if exists, it is overwritten.\r\n     * @param {string} tag The tag name.\r\n     * @param {string} value The tag value.\r\n     * @throws {Error} If the tag name is not valid.\r\n     */\n\n  }, {\n    key: \"setTag\",\n    value: function setTag(tag, value) {\n      tag = fixRIFFTag_(tag);\n      /** @type {!Object} */\n\n      var index = this.getTagIndex_(tag);\n\n      if (index.TAG !== null) {\n        this.LIST[index.LIST].subChunks[index.TAG].chunkSize = value.length + 1;\n        this.LIST[index.LIST].subChunks[index.TAG].value = value;\n      } else if (index.LIST !== null) {\n        this.LIST[index.LIST].subChunks.push({\n          chunkId: tag,\n          chunkSize: value.length + 1,\n          value: value\n        });\n      } else {\n        this.LIST.push({\n          chunkId: 'LIST',\n          chunkSize: 8 + value.length + 1,\n          format: 'INFO',\n          subChunks: []\n        });\n        this.LIST[this.LIST.length - 1].subChunks.push({\n          chunkId: tag,\n          chunkSize: value.length + 1,\n          value: value\n        });\n      }\n    }\n    /**\r\n     * Remove a RIFF tag from the INFO chunk.\r\n     * @param {string} tag The tag name.\r\n     * @return {boolean} True if a tag was deleted.\r\n     */\n\n  }, {\n    key: \"deleteTag\",\n    value: function deleteTag(tag) {\n      /** @type {!Object} */\n      var index = this.getTagIndex_(tag);\n\n      if (index.TAG !== null) {\n        this.LIST[index.LIST].subChunks.splice(index.TAG, 1);\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Return a Object<tag, value> with the RIFF tags in the file.\r\n     * @return {!Object<string, string>} The file tags.\r\n     */\n\n  }, {\n    key: \"listTags\",\n    value: function listTags() {\n      /** @type {?number} */\n      var index = this.getLISTIndex('INFO');\n      /** @type {!Object} */\n\n      var tags = {};\n\n      if (index !== null) {\n        for (var i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\n          tags[this.LIST[index].subChunks[i].chunkId] = this.LIST[index].subChunks[i].value;\n        }\n      }\n\n      return tags;\n    }\n    /**\r\n     * Return the index of a list by its type.\r\n     * @param {string} listType The list type ('adtl', 'INFO')\r\n     * @return {?number}\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"getLISTIndex\",\n    value: function getLISTIndex(listType) {\n      for (var i = 0, len = this.LIST.length; i < len; i++) {\n        if (this.LIST[i].format == listType) {\n          return i;\n        }\n      }\n\n      return null;\n    }\n    /**\r\n     * Return the index of a tag in a FILE chunk.\r\n     * @param {string} tag The tag name.\r\n     * @return {!Object<string, ?number>}\r\n     *    Object.LIST is the INFO index in LIST\r\n     *    Object.TAG is the tag index in the INFO\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getTagIndex_\",\n    value: function getTagIndex_(tag) {\n      /** @type {!Object<string, ?number>} */\n      var index = {\n        LIST: null,\n        TAG: null\n      };\n\n      for (var i = 0, len = this.LIST.length; i < len; i++) {\n        if (this.LIST[i].format == 'INFO') {\n          index.LIST = i;\n\n          for (var j = 0, subLen = this.LIST[i].subChunks.length; j < subLen; j++) {\n            if (this.LIST[i].subChunks[j].chunkId == tag) {\n              index.TAG = j;\n              break;\n            }\n          }\n\n          break;\n        }\n      }\n\n      return index;\n    }\n  }]);\n\n  return WaveFileTagEditor;\n}(WaveFileCreator);\n/**\r\n * Fix a RIFF tag format if possible, throw an error otherwise.\r\n * @param {string} tag The tag name.\r\n * @return {string} The tag name in proper fourCC format.\r\n * @private\r\n */\n\nfunction fixRIFFTag_(tag) {\n  if (tag.constructor !== String) {\n    throw new Error('Invalid tag name.');\n  } else if (tag.length < 4) {\n    for (var i = 0, len = 4 - tag.length; i < len; i++) {\n      tag += ' ';\n    }\n  }\n\n  return tag;\n}","map":{"version":3,"sources":["/Users/eric/test/NSVT-FINAL/my-app/node_modules/wavefile/lib/wavefile-tag-editor.js"],"names":["WaveFileCreator","WaveFileTagEditor","tag","index","getTagIndex_","TAG","LIST","subChunks","value","fixRIFFTag_","chunkSize","length","push","chunkId","format","splice","getLISTIndex","tags","i","len","listType","j","subLen","constructor","String","Error"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileTagEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileCreator } from './wavefile-creator';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileCreator\r\n * @ignore\r\n */\r\nexport class WaveFileTagEditor extends WaveFileCreator {\r\n\r\n  /**\r\n   * Return the value of a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {?string} The value if the tag is found, null otherwise.\r\n   */\r\n  getTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      return this.LIST[index.LIST].subChunks[index.TAG].value;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n   * then it is created. It if exists, it is overwritten.\r\n   * @param {string} tag The tag name.\r\n   * @param {string} value The tag value.\r\n   * @throws {Error} If the tag name is not valid.\r\n   */\r\n  setTag(tag, value) {\r\n    tag = fixRIFFTag_(tag);\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST].subChunks[index.TAG].chunkSize =\r\n        value.length + 1;\r\n      this.LIST[index.LIST].subChunks[index.TAG].value = value;\r\n    } else if (index.LIST !== null) {\r\n      this.LIST[index.LIST].subChunks.push({\r\n        chunkId: tag,\r\n        chunkSize: value.length + 1,\r\n        value: value});\r\n    } else {\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 8 + value.length + 1,\r\n        format: 'INFO',\r\n        subChunks: []});\r\n      this.LIST[this.LIST.length - 1].subChunks.push({\r\n        chunkId: tag,\r\n        chunkSize: value.length + 1,\r\n        value: value});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a RIFF tag from the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {boolean} True if a tag was deleted.\r\n   */\r\n  deleteTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST].subChunks.splice(index.TAG, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return a Object<tag, value> with the RIFF tags in the file.\r\n   * @return {!Object<string, string>} The file tags.\r\n   */\r\n  listTags() {\r\n    /** @type {?number} */\r\n    let index = this.getLISTIndex('INFO');\r\n    /** @type {!Object} */\r\n    let tags = {};\r\n    if (index !== null) {\r\n      for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n        tags[this.LIST[index].subChunks[i].chunkId] =\r\n          this.LIST[index].subChunks[i].value;\r\n      }\r\n    }\r\n    return tags;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a list by its type.\r\n   * @param {string} listType The list type ('adtl', 'INFO')\r\n   * @return {?number}\r\n   * @protected\r\n   */\r\n  getLISTIndex(listType) {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == listType) {\r\n        return i;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a tag in a FILE chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {!Object<string, ?number>}\r\n   *    Object.LIST is the INFO index in LIST\r\n   *    Object.TAG is the tag index in the INFO\r\n   * @private\r\n   */\r\n  getTagIndex_(tag) {\r\n    /** @type {!Object<string, ?number>} */\r\n    let index = {LIST: null, TAG: null};\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'INFO') {\r\n        index.LIST = i;\r\n        for (let j=0, subLen = this.LIST[i].subChunks.length; j < subLen; j++) {\r\n          if (this.LIST[i].subChunks[j].chunkId == tag) {\r\n            index.TAG = j;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n}\r\n\r\n/**\r\n * Fix a RIFF tag format if possible, throw an error otherwise.\r\n * @param {string} tag The tag name.\r\n * @return {string} The tag name in proper fourCC format.\r\n * @private\r\n */\r\nfunction fixRIFFTag_(tag) {\r\n  if (tag.constructor !== String) {\r\n    throw new Error('Invalid tag name.');\r\n  } else if (tag.length < 4) {\r\n    for (let i = 0, len = 4 - tag.length; i < len; i++) {\r\n      tag += ' ';\r\n    }\r\n  }\r\n  return tag;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}