{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/NSVT-FINAL/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\n\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\nexport var FloatParser = /*#__PURE__*/function () {\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\n  function FloatParser(ebits, fbits) {\n    _classCallCheck(this, FloatParser);\n\n    /**\r\n     * @type {number}\r\n     */\n    this.offset = Math.ceil((ebits + fbits) / 8);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.ebits = ebits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.fbits = fbits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.bias = (1 << ebits - 1) - 1;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.biasP2 = Math.pow(2, this.bias + 1);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.ebitsFbits = ebits + fbits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\n  }\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\n\n\n  _createClass(FloatParser, [{\n    key: \"pack\",\n    value: function pack(buffer, num, index) {\n      // Round overflows\n      if (Math.abs(num) > this.biasP2 - this.ebitsFbits * 2) {\n        num = num < 0 ? -Infinity : Infinity;\n      }\n      /**\r\n       * sign, need this to handle negative zero\r\n       * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n       * @type {number}\r\n       */\n\n\n      var sign = ((num = +num) || 1 / num) < 0 ? 1 : num < 0 ? 1 : 0;\n      num = Math.abs(num);\n      /** @type {number} */\n\n      var exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\n      /** @type {number} */\n\n      var fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits)); // NaN\n\n      if (num !== num) {\n        fraction = Math.pow(2, this.fbits - 1);\n        exp = (1 << this.ebits) - 1; // Number\n      } else if (num !== 0) {\n        if (num >= Math.pow(2, 1 - this.bias)) {\n          if (fraction / Math.pow(2, this.fbits) >= 2) {\n            exp = exp + 1;\n            fraction = 1;\n          } // Overflow\n\n\n          if (exp > this.bias) {\n            exp = (1 << this.ebits) - 1;\n            fraction = 0;\n          } else {\n            exp = exp + this.bias;\n            fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\n          }\n        } else {\n          fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\n          exp = 0;\n        }\n      }\n\n      return this.packFloatBits_(buffer, index, sign, exp, fraction);\n    }\n    /**\r\n     * Unpack a IEEE 754 floating point number.\r\n     * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n     * Adapted to handle NaN. Should port the solution to the original repo.\r\n     * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n     * @param {number} index The index to read from the buffer.\r\n     * @return {number} The floating point number.\r\n     */\n\n  }, {\n    key: \"unpack\",\n    value: function unpack(buffer, index) {\n      /** @type {number} */\n      var eMax = (1 << this.ebits) - 1;\n      /** @type {number} */\n\n      var significand;\n      /** @type {string} */\n\n      var leftBits = \"\";\n\n      for (var i = this.offset - 1; i >= 0; i--) {\n        /** @type {string} */\n        var t = buffer[i + index].toString(2);\n        leftBits += \"00000000\".substring(t.length) + t;\n      }\n      /** @type {number} */\n\n\n      var sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\n      leftBits = leftBits.substring(1);\n      /** @type {number} */\n\n      var exponent = parseInt(leftBits.substring(0, this.ebits), 2);\n      leftBits = leftBits.substring(this.ebits);\n\n      if (exponent == eMax) {\n        if (parseInt(leftBits, 2) !== 0) {\n          return NaN;\n        }\n\n        return sign * Infinity;\n      } else if (exponent === 0) {\n        exponent += 1;\n        significand = parseInt(leftBits, 2);\n      } else {\n        significand = parseInt(\"1\" + leftBits, 2);\n      }\n\n      return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\n    }\n    /**\r\n     * Pack a IEEE754 from its sign, exponent and fraction bits\r\n     * and place it in a byte buffer.\r\n     * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n     * @param {number} index The buffer index to write.\r\n     * @param {number} sign The sign.\r\n     * @param {number} exp the exponent.\r\n     * @param {number} fraction The fraction.\r\n     * @return {number}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"packFloatBits_\",\n    value: function packFloatBits_(buffer, index, sign, exp, fraction) {\n      /** @type {!Array<number>} */\n      var bits = []; // the sign\n\n      bits.push(sign); // the exponent\n\n      for (var i = this.ebits; i > 0; i -= 1) {\n        bits[i] = exp % 2 ? 1 : 0;\n        exp = Math.floor(exp / 2);\n      } // the fraction\n\n\n      var len = bits.length;\n\n      for (var _i = this.fbits; _i > 0; _i -= 1) {\n        bits[len + _i] = fraction % 2 ? 1 : 0;\n        fraction = Math.floor(fraction / 2);\n      } // pack as bytes\n\n      /** @type {string} */\n\n\n      var str = bits.join('');\n      /** @type {number} */\n\n      var offset = this.offset + index - 1;\n      /** @type {number} */\n\n      var k = index;\n\n      while (offset >= index) {\n        buffer[offset] = parseInt(str.substring(0, 8), 2);\n        str = str.substring(8);\n        offset--;\n        k++;\n      }\n\n      return k;\n    }\n  }]);\n\n  return FloatParser;\n}();\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\n\nfunction roundToEven(n) {\n  /** @type {number} */\n  var w = Math.floor(n);\n  var f = n - w;\n\n  if (f < 0.5) {\n    return w;\n  }\n\n  if (f > 0.5) {\n    return w + 1;\n  }\n\n  return w % 2 ? w + 1 : w;\n}","map":{"version":3,"sources":["/Users/eric/test/NSVT-FINAL/my-app/node_modules/wavefile/lib/parsers/binary/lib/float-parser.js"],"names":["FloatParser","ebits","fbits","offset","Math","ceil","bias","biasP2","pow","ebitsFbits","fbias","buffer","num","index","abs","Infinity","sign","exp","min","floor","log","LN2","fraction","roundToEven","packFloatBits_","eMax","significand","leftBits","i","t","toString","substring","length","charAt","exponent","parseInt","NaN","bits","push","len","str","join","k","n","w","f"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\r\n\r\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\r\nexport class FloatParser {\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\r\n  constructor(ebits, fbits) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil((ebits + fbits) / 8);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebits = ebits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbits = fbits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.bias = (1 << (ebits - 1)) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.biasP2 = Math.pow(2, this.bias + 1);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebitsFbits = (ebits + fbits);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\r\n  pack(buffer, num, index) {\r\n    // Round overflows\r\n    if (Math.abs(num) > this.biasP2 - (this.ebitsFbits * 2)) {\r\n      num = num < 0 ? -Infinity : Infinity;\r\n    }\r\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\r\n    let sign = (((num = +num) || 1 / num) < 0) ? 1 : num < 0 ? 1 : 0;\r\n    num = Math.abs(num);\r\n    /** @type {number} */\r\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\r\n    /** @type {number} */\r\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));\r\n    // NaN\r\n    if (num !== num) {\r\n      fraction = Math.pow(2, this.fbits - 1);\r\n      exp = (1 << this.ebits) - 1;\r\n    // Number\r\n    } else if (num !== 0) {\r\n      if (num >= Math.pow(2, 1 - this.bias)) {\r\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\r\n          exp = exp + 1;\r\n          fraction = 1;\r\n        }\r\n        // Overflow\r\n        if (exp > this.bias) {\r\n          exp = (1 << this.ebits) - 1;\r\n          fraction = 0;\r\n        } else {\r\n          exp = exp + this.bias;\r\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\r\n        }\r\n      } else {\r\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\r\n        exp = 0;\r\n      } \r\n    }\r\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\r\n  }\r\n\r\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\r\n  unpack(buffer, index) {\r\n    /** @type {number} */\r\n    let eMax = (1 << this.ebits) - 1;\r\n    /** @type {number} */\r\n    let significand;\r\n    /** @type {string} */\r\n    let leftBits = \"\";\r\n    for (let i = this.offset - 1; i >= 0 ; i--) {\r\n      /** @type {string} */\r\n      let t = buffer[i + index].toString(2);\r\n      leftBits += \"00000000\".substring(t.length) + t;\r\n    }\r\n    /** @type {number} */\r\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\r\n    leftBits = leftBits.substring(1);\r\n    /** @type {number} */\r\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\r\n    leftBits = leftBits.substring(this.ebits);\r\n    if (exponent == eMax) {\r\n      if (parseInt(leftBits, 2) !== 0) {\r\n        return NaN;\r\n      }\r\n      return sign * Infinity;  \r\n    } else if (exponent === 0) {\r\n      exponent += 1;\r\n      significand = parseInt(leftBits, 2);\r\n    } else {\r\n      significand = parseInt(\"1\" + leftBits, 2);\r\n    }\r\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  packFloatBits_(buffer, index, sign, exp, fraction) {\r\n    /** @type {!Array<number>} */\r\n    let bits = [];\r\n    // the sign\r\n    bits.push(sign);\r\n    // the exponent\r\n    for (let i = this.ebits; i > 0; i -= 1) {\r\n      bits[i] = (exp % 2 ? 1 : 0);\r\n      exp = Math.floor(exp / 2);\r\n    }\r\n    // the fraction\r\n    let len = bits.length;\r\n    for (let i = this.fbits; i > 0; i -= 1) {\r\n      bits[len + i] = (fraction % 2 ? 1 : 0);\r\n      fraction = Math.floor(fraction / 2);\r\n    }\r\n    // pack as bytes\r\n    /** @type {string} */\r\n    let str = bits.join('');\r\n    /** @type {number} */\r\n    let offset = this.offset + index - 1;\r\n    /** @type {number} */\r\n    let k = index;\r\n    while (offset >= index) {\r\n      buffer[offset] = parseInt(str.substring(0, 8), 2);\r\n      str = str.substring(8);\r\n      offset--;\r\n      k++;\r\n    }\r\n    return k;\r\n  }\r\n}\r\n\r\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction roundToEven(n) {\r\n  /** @type {number} */\r\n  let w = Math.floor(n);\r\n  let f = n - w;\r\n  if (f < 0.5) {\r\n    return w;\r\n  }\r\n  if (f > 0.5) {\r\n    return w + 1;\r\n  }\r\n  return w % 2 ? w + 1 : w;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}