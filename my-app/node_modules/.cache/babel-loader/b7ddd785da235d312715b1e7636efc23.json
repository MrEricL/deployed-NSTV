{"ast":null,"code":"import _classCallCheck from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/eric/test/herokutestcs/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\n\nexport var WaveFileCueEditor = /*#__PURE__*/function (_WaveFileTagEditor) {\n  _inherits(WaveFileCueEditor, _WaveFileTagEditor);\n\n  var _super = _createSuper(WaveFileCueEditor);\n\n  function WaveFileCueEditor() {\n    _classCallCheck(this, WaveFileCueEditor);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(WaveFileCueEditor, [{\n    key: \"listCuePoints\",\n    value:\n    /**\r\n     * Return an array with all cue points in the file, in the order they appear\r\n     * in the file.\r\n     * Objects representing cue points/regions look like this:\r\n     *   {\r\n     *     position: 500, // the position in milliseconds\r\n     *     label: 'cue marker 1',\r\n     *     end: 1500, // the end position in milliseconds\r\n     *     dwName: 1,\r\n     *     dwPosition: 0,\r\n     *     fccChunk: 'data',\r\n     *     dwChunkStart: 0,\r\n     *     dwBlockStart: 0,\r\n     *     dwSampleOffset: 22050, // the position as a sample offset\r\n     *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n     *     dwPurposeID: 544106354,\r\n     *     dwCountry: 0,\r\n     *     dwLanguage: 0,\r\n     *     dwDialect: 0,\r\n     *     dwCodePage: 0,\r\n     *   }\r\n     * @return {!Array<Object>}\r\n     */\n    function listCuePoints() {\n      /** @type {!Array<!Object>} */\n      var points = this.getCuePoints_();\n\n      for (var i = 0, len = points.length; i < len; i++) {\n        // Add attrs that should exist in the object\n        points[i].position = points[i].dwSampleOffset / this.fmt.sampleRate * 1000; // If it is a region, calc the end\n        // position in milliseconds\n\n        if (points[i].dwSampleLength) {\n          points[i].end = points[i].dwSampleLength / this.fmt.sampleRate * 1000;\n          points[i].end += points[i].position; // If its not a region, end should be null\n        } else {\n          points[i].end = null;\n        } // Remove attrs that should not go in the results\n\n\n        delete points[i].value;\n      }\n\n      return points;\n    }\n    /**\r\n     * Create a cue point in the wave file.\r\n     * @param {!{\r\n     *   position: number,\r\n     *   label: ?string,\r\n     *   end: ?number,\r\n     *   dwPurposeID: ?number,\r\n     *   dwCountry: ?number,\r\n     *   dwLanguage: ?number,\r\n     *   dwDialect: ?number,\r\n     *   dwCodePage: ?number\r\n     * }} pointData A object with the data of the cue point.\r\n     *\r\n     * # Only required attribute to create a cue point:\r\n     * pointData.position: The position of the point in milliseconds\r\n     *\r\n     * # Optional attribute for cue points:\r\n     * pointData.label: A string label for the cue point\r\n     *\r\n     * # Extra data used for regions\r\n     * pointData.end: A number representing the end of the region,\r\n     *   in milliseconds, counting from the start of the file. If\r\n     *   no end attr is specified then no region is created.\r\n     *\r\n     * # You may also specify the following attrs for regions, all optional:\r\n     * pointData.dwPurposeID\r\n     * pointData.dwCountry\r\n     * pointData.dwLanguage\r\n     * pointData.dwDialect\r\n     * pointData.dwCodePage\r\n     */\n\n  }, {\n    key: \"setCuePoint\",\n    value: function setCuePoint(pointData) {\n      this.cue.chunkId = 'cue '; // label attr should always exist\n\n      if (!pointData.label) {\n        pointData.label = '';\n      }\n      /**\r\n       * Load the existing points before erasing\r\n       * the LIST 'adtl' chunk and the cue attr\r\n       * @type {!Array<!Object>}\r\n       */\n\n\n      var existingPoints = this.getCuePoints_(); // Clear any LIST labeled 'adtl'\n      // The LIST chunk should be re-written\n      // after the new cue point is created\n\n      this.clearLISTadtl_(); // Erase this.cue so it can be re-written\n      // after the point is added\n\n      this.cue.points = [];\n      /**\r\n       * Cue position param is informed in milliseconds,\r\n       * here its value is converted to the sample offset\r\n       * @type {number}\r\n       */\n\n      pointData.dwSampleOffset = pointData.position * this.fmt.sampleRate / 1000;\n      /**\r\n       * end param is informed in milliseconds, counting\r\n       * from the start of the file.\r\n       * here its value is converted to the sample length\r\n       * of the region.\r\n       * @type {number}\r\n       */\n\n      pointData.dwSampleLength = 0;\n\n      if (pointData.end) {\n        pointData.dwSampleLength = pointData.end * this.fmt.sampleRate / 1000 - pointData.dwSampleOffset;\n      } // If there were no cue points in the file,\n      // insert the new cue point as the first\n\n\n      if (existingPoints.length === 0) {\n        this.setCuePoint_(pointData, 1); // If the file already had cue points, This new one\n        // must be added in the list according to its position.\n      } else {\n        this.setCuePointInOrder_(existingPoints, pointData);\n      }\n\n      this.cue.dwCuePoints = this.cue.points.length;\n    }\n    /**\r\n     * Remove a cue point from a wave file.\r\n     * @param {number} index the index of the point. First is 1,\r\n     *    second is 2, and so on.\r\n     */\n\n  }, {\n    key: \"deleteCuePoint\",\n    value: function deleteCuePoint(index) {\n      this.cue.chunkId = 'cue ';\n      /** @type {!Array<!Object>} */\n\n      var existingPoints = this.getCuePoints_();\n      this.clearLISTadtl_();\n      /** @type {number} */\n\n      var len = this.cue.points.length;\n      this.cue.points = [];\n\n      for (var i = 0; i < len; i++) {\n        if (i + 1 !== index) {\n          this.setCuePoint_(existingPoints[i], i + 1);\n        }\n      }\n\n      this.cue.dwCuePoints = this.cue.points.length;\n\n      if (this.cue.dwCuePoints) {\n        this.cue.chunkId = 'cue ';\n      } else {\n        this.cue.chunkId = '';\n        this.clearLISTadtl_();\n      }\n    }\n    /**\r\n     * Update the label of a cue point.\r\n     * @param {number} pointIndex The ID of the cue point.\r\n     * @param {string} label The new text for the label.\r\n     */\n\n  }, {\n    key: \"updateLabel\",\n    value: function updateLabel(pointIndex, label) {\n      /** @type {?number} */\n      var cIndex = this.getLISTIndex('adtl');\n\n      if (cIndex !== null) {\n        for (var i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\n          if (this.LIST[cIndex].subChunks[i].dwName == pointIndex) {\n            this.LIST[cIndex].subChunks[i].value = label;\n          }\n        }\n      }\n    }\n    /**\r\n     * Return an array with all cue points in the file, in the order they appear\r\n     * in the file.\r\n     * @return {!Array<!Object>}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getCuePoints_\",\n    value: function getCuePoints_() {\n      /** @type {!Array<!Object>} */\n      var points = [];\n\n      for (var i = 0; i < this.cue.points.length; i++) {\n        /** @type {!Object} */\n        var chunk = this.cue.points[i];\n        /** @type {!Object} */\n\n        var pointData = this.getDataForCuePoint_(chunk.dwName);\n        pointData.label = pointData.value ? pointData.value : '';\n        pointData.dwPosition = chunk.dwPosition;\n        pointData.fccChunk = chunk.fccChunk;\n        pointData.dwChunkStart = chunk.dwChunkStart;\n        pointData.dwBlockStart = chunk.dwBlockStart;\n        pointData.dwSampleOffset = chunk.dwSampleOffset;\n        points.push(pointData);\n      }\n\n      return points;\n    }\n    /**\r\n     * Return the associated data of a cue point.\r\n     * @param {number} pointDwName The ID of the cue point.\r\n     * @return {!Object}\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getDataForCuePoint_\",\n    value: function getDataForCuePoint_(pointDwName) {\n      /** @type {?number} */\n      var LISTindex = this.getLISTIndex('adtl');\n      /** @type {!Object} */\n\n      var pointData = {}; // If there is a adtl LIST in the file, look for\n      // LIST subchunks with data referencing this point\n\n      if (LISTindex !== null) {\n        this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\n      }\n\n      return pointData;\n    }\n    /**\r\n     * Get all data associated to a cue point in a LIST chunk.\r\n     * @param {!Object} pointData A object to hold the point data.\r\n     * @param {number} index The index of the adtl LIST chunk.\r\n     * @param {number} pointDwName The ID of the cue point.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getCueDataFromLIST_\",\n    value: function getCueDataFromLIST_(pointData, index, pointDwName) {\n      // got through all chunks in the adtl LIST checking\n      // for references to this cue point\n      for (var i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\n        if (this.LIST[index].subChunks[i].dwName == pointDwName) {\n          /** @type {!Object} */\n          var chunk = this.LIST[index].subChunks[i]; // Some chunks may reference the point but\n          // have a empty text; this is to ensure that if\n          // one chunk that reference the point has a text,\n          // this value will be kept as the associated data label\n          // for the cue point.\n          // If different values are present, the last value found\n          // will be considered the label for the cue point.\n\n          pointData.value = chunk.value || pointData.value;\n          pointData.dwName = chunk.dwName || 0;\n          pointData.dwSampleLength = chunk.dwSampleLength || 0;\n          pointData.dwPurposeID = chunk.dwPurposeID || 0;\n          pointData.dwCountry = chunk.dwCountry || 0;\n          pointData.dwLanguage = chunk.dwLanguage || 0;\n          pointData.dwDialect = chunk.dwDialect || 0;\n          pointData.dwCodePage = chunk.dwCodePage || 0;\n        }\n      }\n    }\n    /**\r\n     * Push a new cue point in this.cue.points.\r\n     * @param {!Object} pointData A object with data of the cue point.\r\n     * @param {number} dwName the dwName of the cue point\r\n     * @private\r\n     */\n\n  }, {\n    key: \"setCuePoint_\",\n    value: function setCuePoint_(pointData, dwName) {\n      this.cue.points.push({\n        dwName: dwName,\n        dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\n        fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\n        dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\n        dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\n        dwSampleOffset: pointData.dwSampleOffset\n      });\n      this.setLabl_(pointData, dwName);\n    }\n    /**\r\n     * Push a new cue point in this.cue.points according to existing cue points.\r\n     * @param {!Array} existingPoints Array with the existing points.\r\n     * @param {!Object} pointData A object with data of the cue point.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"setCuePointInOrder_\",\n    value: function setCuePointInOrder_(existingPoints, pointData) {\n      /** @type {boolean} */\n      var hasSet = false; // Iterate over the cue points that existed\n      // before this one was added\n\n      for (var i = 0; i < existingPoints.length; i++) {\n        // If the new point is located before this original point\n        // and the new point have not been created, create the\n        // new point and then the original point\n        if (existingPoints[i].dwSampleOffset > pointData.dwSampleOffset && !hasSet) {\n          // create the new point\n          this.setCuePoint_(pointData, i + 1); // create the original point\n\n          this.setCuePoint_(existingPoints[i], i + 2);\n          hasSet = true; // Otherwise, re-create the original point\n        } else {\n          this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\n        }\n      } // If no point was created in the above loop,\n      // create the new point as the last one\n\n\n      if (!hasSet) {\n        this.setCuePoint_(pointData, this.cue.points.length + 1);\n      }\n    }\n    /**\r\n     * Clear any LIST chunk labeled as 'adtl'.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"clearLISTadtl_\",\n    value: function clearLISTadtl_() {\n      for (var i = 0, len = this.LIST.length; i < len; i++) {\n        if (this.LIST[i].format == 'adtl') {\n          this.LIST.splice(i);\n        }\n      }\n    }\n    /**\r\n     * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n     * This method creates a LIST adtl chunk in the file if one\r\n     * is not present.\r\n     * @param {!Object} pointData A object with data of the cue point.\r\n     * @param {number} dwName The ID of the cue point.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"setLabl_\",\n    value: function setLabl_(pointData, dwName) {\n      /**\r\n       * Get the index of the LIST chunk labeled as adtl.\r\n       * A file can have many LIST chunks with unique labels.\r\n       * @type {?number}\r\n       */\n      var adtlIndex = this.getLISTIndex('adtl'); // If there is no adtl LIST, create one\n\n      if (adtlIndex === null) {\n        // Include a new item LIST chunk\n        this.LIST.push({\n          chunkId: 'LIST',\n          chunkSize: 4,\n          format: 'adtl',\n          subChunks: []\n        }); // Get the index of the new LIST chunk\n\n        adtlIndex = this.LIST.length - 1;\n      }\n\n      this.setLabelText_(adtlIndex, pointData, dwName);\n\n      if (pointData.dwSampleLength) {\n        this.setLtxtChunk_(adtlIndex, pointData, dwName);\n      }\n    }\n    /**\r\n     * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n     * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n     * @param {!Object} pointData A object with data of the cue point.\r\n     * @param {number} dwName The ID of the cue point.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"setLabelText_\",\n    value: function setLabelText_(adtlIndex, pointData, dwName) {\n      this.LIST[adtlIndex].subChunks.push({\n        chunkId: 'labl',\n        chunkSize: 4,\n        // should be 4 + label length in bytes\n        dwName: dwName,\n        value: pointData.label\n      });\n      this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\n    }\n    /**\r\n     * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n     * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n     * @param {!Object} pointData A object with data of the cue point.\r\n     * @param {number} dwName The ID of the cue point.\r\n     * @private\r\n     */\n\n  }, {\n    key: \"setLtxtChunk_\",\n    value: function setLtxtChunk_(adtlIndex, pointData, dwName) {\n      this.LIST[adtlIndex].subChunks.push({\n        chunkId: 'ltxt',\n        chunkSize: 20,\n        // should be 12 + label byte length\n        dwName: dwName,\n        dwSampleLength: pointData.dwSampleLength,\n        dwPurposeID: pointData.dwPurposeID || 0,\n        dwCountry: pointData.dwCountry || 0,\n        dwLanguage: pointData.dwLanguage || 0,\n        dwDialect: pointData.dwDialect || 0,\n        dwCodePage: pointData.dwCodePage || 0,\n        value: pointData.label // kept for compatibility\n\n      });\n      this.LIST[adtlIndex].chunkSize += 28;\n    }\n  }]);\n\n  return WaveFileCueEditor;\n}(WaveFileTagEditor);","map":{"version":3,"sources":["/Users/eric/test/herokutestcs/my-app/node_modules/wavefile/lib/wavefile-cue-editor.js"],"names":["WaveFileTagEditor","WaveFileCueEditor","points","getCuePoints_","i","len","length","position","dwSampleOffset","fmt","sampleRate","dwSampleLength","end","value","pointData","cue","chunkId","label","existingPoints","clearLISTadtl_","setCuePoint_","setCuePointInOrder_","dwCuePoints","index","pointIndex","cIndex","getLISTIndex","LIST","subChunks","dwName","chunk","getDataForCuePoint_","dwPosition","fccChunk","dwChunkStart","dwBlockStart","push","pointDwName","LISTindex","getCueDataFromLIST_","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","setLabl_","hasSet","format","splice","adtlIndex","chunkSize","setLabelText_","setLtxtChunk_"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\r\nexport class WaveFileCueEditor extends WaveFileTagEditor {\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * Objects representing cue points/regions look like this:\r\n   *   {\r\n   *     position: 500, // the position in milliseconds\r\n   *     label: 'cue marker 1',\r\n   *     end: 1500, // the end position in milliseconds\r\n   *     dwName: 1,\r\n   *     dwPosition: 0,\r\n   *     fccChunk: 'data',\r\n   *     dwChunkStart: 0,\r\n   *     dwBlockStart: 0,\r\n   *     dwSampleOffset: 22050, // the position as a sample offset\r\n   *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n   *     dwPurposeID: 544106354,\r\n   *     dwCountry: 0,\r\n   *     dwLanguage: 0,\r\n   *     dwDialect: 0,\r\n   *     dwCodePage: 0,\r\n   *   }\r\n   * @return {!Array<Object>}\r\n   */\r\n  listCuePoints() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = this.getCuePoints_();\r\n    for (let i = 0, len = points.length; i < len; i++) {\r\n\r\n      // Add attrs that should exist in the object\r\n      points[i].position =\r\n        (points[i].dwSampleOffset / this.fmt.sampleRate) * 1000;\r\n\r\n      // If it is a region, calc the end\r\n      // position in milliseconds\r\n      if (points[i].dwSampleLength) {\r\n        points[i].end =\r\n          (points[i].dwSampleLength / this.fmt.sampleRate) * 1000;\r\n        points[i].end += points[i].position;\r\n      // If its not a region, end should be null\r\n      } else {\r\n        points[i].end = null;\r\n      }\r\n\r\n      // Remove attrs that should not go in the results\r\n      delete points[i].value;\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {!{\r\n   *   position: number,\r\n   *   label: ?string,\r\n   *   end: ?number,\r\n   *   dwPurposeID: ?number,\r\n   *   dwCountry: ?number,\r\n   *   dwLanguage: ?number,\r\n   *   dwDialect: ?number,\r\n   *   dwCodePage: ?number\r\n   * }} pointData A object with the data of the cue point.\r\n   *\r\n   * # Only required attribute to create a cue point:\r\n   * pointData.position: The position of the point in milliseconds\r\n   *\r\n   * # Optional attribute for cue points:\r\n   * pointData.label: A string label for the cue point\r\n   *\r\n   * # Extra data used for regions\r\n   * pointData.end: A number representing the end of the region,\r\n   *   in milliseconds, counting from the start of the file. If\r\n   *   no end attr is specified then no region is created.\r\n   *\r\n   * # You may also specify the following attrs for regions, all optional:\r\n   * pointData.dwPurposeID\r\n   * pointData.dwCountry\r\n   * pointData.dwLanguage\r\n   * pointData.dwDialect\r\n   * pointData.dwCodePage\r\n   */\r\n  setCuePoint(pointData) {\r\n    this.cue.chunkId = 'cue ';\r\n\r\n    // label attr should always exist\r\n    if (!pointData.label) {\r\n      pointData.label = '';\r\n    }\r\n\r\n    /**\r\n     * Load the existing points before erasing\r\n     * the LIST 'adtl' chunk and the cue attr\r\n     * @type {!Array<!Object>}\r\n     */\r\n    let existingPoints = this.getCuePoints_();\r\n\r\n    // Clear any LIST labeled 'adtl'\r\n    // The LIST chunk should be re-written\r\n    // after the new cue point is created\r\n    this.clearLISTadtl_();\r\n\r\n    // Erase this.cue so it can be re-written\r\n    // after the point is added\r\n    this.cue.points = [];\r\n\r\n    /**\r\n     * Cue position param is informed in milliseconds,\r\n     * here its value is converted to the sample offset\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleOffset =\r\n      (pointData.position * this.fmt.sampleRate) / 1000;\r\n    /**\r\n     * end param is informed in milliseconds, counting\r\n     * from the start of the file.\r\n     * here its value is converted to the sample length\r\n     * of the region.\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleLength = 0;\r\n    if (pointData.end) {\r\n      pointData.dwSampleLength = \r\n        ((pointData.end * this.fmt.sampleRate) / 1000) -\r\n        pointData.dwSampleOffset;\r\n    }\r\n\r\n    // If there were no cue points in the file,\r\n    // insert the new cue point as the first\r\n    if (existingPoints.length === 0) {\r\n      this.setCuePoint_(pointData, 1);\r\n\r\n    // If the file already had cue points, This new one\r\n    // must be added in the list according to its position.\r\n    } else {\r\n      this.setCuePointInOrder_(existingPoints, pointData);\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n  }\r\n\r\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   */\r\n  deleteCuePoint(index) {\r\n    this.cue.chunkId = 'cue ';\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    for (let i = 0; i < len; i++) {\r\n      if (i + 1 !== index) {\r\n        this.setCuePoint_(existingPoints[i], i + 1);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n    if (this.cue.dwCuePoints) {\r\n      this.cue.chunkId = 'cue ';\r\n    } else {\r\n      this.cue.chunkId = '';\r\n      this.clearLISTadtl_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   */\r\n  updateLabel(pointIndex, label) {\r\n    /** @type {?number} */\r\n    let cIndex = this.getLISTIndex('adtl');\r\n    if (cIndex !== null) {\r\n      for (let i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\r\n        if (this.LIST[cIndex].subChunks[i].dwName ==\r\n            pointIndex) {\r\n          this.LIST[cIndex].subChunks[i].value = label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\r\n  getCuePoints_() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = [];\r\n    for (let i = 0; i < this.cue.points.length; i++) {\r\n      /** @type {!Object} */\r\n      let chunk = this.cue.points[i];\r\n      /** @type {!Object} */\r\n      let pointData = this.getDataForCuePoint_(chunk.dwName);\r\n      pointData.label = pointData.value ? pointData.value : '';\r\n      pointData.dwPosition = chunk.dwPosition;\r\n      pointData.fccChunk = chunk.fccChunk;\r\n      pointData.dwChunkStart = chunk.dwChunkStart;\r\n      pointData.dwBlockStart = chunk.dwBlockStart;\r\n      pointData.dwSampleOffset = chunk.dwSampleOffset;\r\n      points.push(pointData);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the associated data of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {!Object}\r\n   * @private\r\n   */\r\n  getDataForCuePoint_(pointDwName) {\r\n    /** @type {?number} */\r\n    let LISTindex = this.getLISTIndex('adtl');\r\n    /** @type {!Object} */\r\n    let pointData = {};\r\n    // If there is a adtl LIST in the file, look for\r\n    // LIST subchunks with data referencing this point\r\n    if (LISTindex !== null) {\r\n      this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\r\n    }\r\n    return pointData;\r\n  }\r\n\r\n  /**\r\n   * Get all data associated to a cue point in a LIST chunk.\r\n   * @param {!Object} pointData A object to hold the point data.\r\n   * @param {number} index The index of the adtl LIST chunk.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  getCueDataFromLIST_(pointData, index, pointDwName) {\r\n    // got through all chunks in the adtl LIST checking\r\n    // for references to this cue point\r\n    for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n      if (this.LIST[index].subChunks[i].dwName == pointDwName) {\r\n        /** @type {!Object} */\r\n        let chunk = this.LIST[index].subChunks[i];\r\n        // Some chunks may reference the point but\r\n        // have a empty text; this is to ensure that if\r\n        // one chunk that reference the point has a text,\r\n        // this value will be kept as the associated data label\r\n        // for the cue point.\r\n        // If different values are present, the last value found\r\n        // will be considered the label for the cue point.\r\n        pointData.value = chunk.value || pointData.value;\r\n        pointData.dwName = chunk.dwName || 0;\r\n        pointData.dwSampleLength = chunk.dwSampleLength || 0;\r\n        pointData.dwPurposeID = chunk.dwPurposeID || 0;\r\n        pointData.dwCountry = chunk.dwCountry || 0;\r\n        pointData.dwLanguage = chunk.dwLanguage || 0;\r\n        pointData.dwDialect = chunk.dwDialect || 0;\r\n        pointData.dwCodePage = chunk.dwCodePage || 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\r\n  setCuePoint_(pointData, dwName) {\r\n    this.cue.points.push({\r\n      dwName: dwName,\r\n      dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\r\n      fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\r\n      dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\r\n      dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\r\n      dwSampleOffset: pointData.dwSampleOffset\r\n    });\r\n    this.setLabl_(pointData, dwName);\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points according to existing cue points.\r\n   * @param {!Array} existingPoints Array with the existing points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @private\r\n   */\r\n  setCuePointInOrder_(existingPoints, pointData) {\r\n    /** @type {boolean} */\r\n    let hasSet = false;\r\n\r\n    // Iterate over the cue points that existed\r\n    // before this one was added\r\n    for (let i = 0; i < existingPoints.length; i++) {\r\n\r\n      // If the new point is located before this original point\r\n      // and the new point have not been created, create the\r\n      // new point and then the original point\r\n      if (existingPoints[i].dwSampleOffset > \r\n        pointData.dwSampleOffset && !hasSet) {\r\n        // create the new point\r\n        this.setCuePoint_(pointData, i + 1);\r\n\r\n        // create the original point\r\n        this.setCuePoint_(existingPoints[i], i + 2);\r\n        hasSet = true;\r\n\r\n      // Otherwise, re-create the original point\r\n      } else {\r\n        this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\r\n      }\r\n    }\r\n    // If no point was created in the above loop,\r\n    // create the new point as the last one\r\n    if (!hasSet) {\r\n      this.setCuePoint_(pointData, this.cue.points.length + 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\r\n  clearLISTadtl_() {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'adtl') {\r\n        this.LIST.splice(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * This method creates a LIST adtl chunk in the file if one\r\n   * is not present.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabl_(pointData, dwName) {\r\n    /**\r\n     * Get the index of the LIST chunk labeled as adtl.\r\n     * A file can have many LIST chunks with unique labels.\r\n     * @type {?number}\r\n     */\r\n    let adtlIndex = this.getLISTIndex('adtl');\r\n    // If there is no adtl LIST, create one\r\n    if (adtlIndex === null) {\r\n      // Include a new item LIST chunk\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 4,\r\n        format: 'adtl',\r\n        subChunks: []});\r\n      // Get the index of the new LIST chunk\r\n      adtlIndex = this.LIST.length - 1;\r\n    }\r\n    this.setLabelText_(adtlIndex, pointData, dwName);\r\n    if (pointData.dwSampleLength) {\r\n      this.setLtxtChunk_(adtlIndex, pointData, dwName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabelText_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'labl',\r\n      chunkSize: 4, // should be 4 + label length in bytes\r\n      dwName: dwName,\r\n      value: pointData.label\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\r\n  }\r\n  /**\r\n   * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLtxtChunk_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'ltxt',\r\n      chunkSize: 20,  // should be 12 + label byte length\r\n      dwName: dwName,\r\n      dwSampleLength: pointData.dwSampleLength,\r\n      dwPurposeID: pointData.dwPurposeID || 0,\r\n      dwCountry: pointData.dwCountry || 0,\r\n      dwLanguage: pointData.dwLanguage || 0,\r\n      dwDialect: pointData.dwDialect || 0,\r\n      dwCodePage: pointData.dwCodePage || 0,\r\n      value: pointData.label // kept for compatibility\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 28;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}